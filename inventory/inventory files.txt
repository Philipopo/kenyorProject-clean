serializer.py:

from rest_framework import serializers
from django.db import transaction
from .models import Warehouse, StorageBin, Item, StockRecord, StockMovement, InventoryAlert, ExpiryTrackedItem, InventoryActivityLog, WarehouseReceipt
import logging
from django.utils import timezone  # Add this import
import uuid

logger = logging.getLogger(__name__)

class WarehouseSerializer(serializers.ModelSerializer):
    total_bins = serializers.ReadOnlyField()
    used_capacity = serializers.ReadOnlyField()
    available_capacity = serializers.ReadOnlyField()
    usage_percentage = serializers.ReadOnlyField()
    created_by = serializers.SerializerMethodField()
    bin_locations = serializers.SerializerMethodField()
    state = serializers.CharField(max_length=100, required=False, allow_blank=True)
    country = serializers.CharField(max_length=100, required=False, allow_blank=True)

    class Meta:
        model = Warehouse
        fields = [
            'id', 'name', 'code', 'description', 'address', 'city', 'state', 'country',
            'capacity', 'is_active', 'total_bins', 'used_capacity', 'available_capacity',
            'usage_percentage', 'user', 'created_by', 'created_at', 'updated_at', 'bin_locations'
        ]
        read_only_fields = ['user', 'created_at', 'updated_at']

    def get_created_by(self, obj):
        if obj.user:
            return obj.user.name or obj.user.email
        return '—'

    def get_bin_locations(self, obj):
        bins = obj.bins.select_related('warehouse').all().order_by('row', 'rack', 'shelf')
        locations = {}
        for bin in bins:
            if bin.row not in locations:
                locations[bin.row] = {}
            if bin.rack not in locations[bin.row]:
                locations[bin.row][bin.rack] = []
            locations[bin.row][bin.rack].append({
                'id': bin.id,
                'shelf': bin.shelf,
                'bin_id': bin.bin_id,
                'type': bin.type,
                'capacity': bin.capacity,
                'current_load': bin.current_load,
                'usage_percentage': bin.usage_percentage,
                'description': bin.description
            })
        return locations

class ItemSerializer(serializers.ModelSerializer):
    material_id = serializers.CharField(read_only=True)
    total_quantity = serializers.SerializerMethodField()
    available_quantity = serializers.SerializerMethodField()
    created_by = serializers.SerializerMethodField()

    class Meta:
        model = Item
        fields = [
            'id', 'material_id', 'name', 'description', 'part_number', 'manufacturer', 'contact', 'batch', 'expiry_date',
            'min_stock_level', 'reserved_quantity', 'custom_fields', 'user', 'created_at',
            'total_quantity', 'available_quantity', 'created_by'
        ]
        read_only_fields = ['id', 'material_id', 'user', 'created_at', 'total_quantity', 'available_quantity', 'created_by']

    def get_total_quantity(self, obj):
        return obj.total_quantity()

    def get_available_quantity(self, obj):
        return obj.available_quantity()

    def get_created_by(self, obj):
        user = obj.user
        if user:
            try:
                profile = user.profile
                if profile and profile.full_name:
                    return profile.full_name
            except:
                pass
            return user.name or user.email
        return '—'

    def validate_reserved_quantity(self, value):
        if value < 0:
            raise serializers.ValidationError("Reserved quantity cannot be negative.")
        
        instance = getattr(self, 'instance', None)
        
        if instance:
            total_qty = instance.total_quantity()
            if value > total_qty:
                raise serializers.ValidationError(
                    f"Reserved quantity ({value}) cannot exceed total stock ({total_qty}). "
                    f"Please add stock inflow first."
                )
        else:
            if value > 0:
                raise serializers.ValidationError(
                    "Reserved quantity must be 0 for new items. Please add stock inflow first."
                )
        
        return value

    def validate(self, data):
        reserved_qty = data.get('reserved_quantity', getattr(self.instance, 'reserved_quantity', 0))
        
        if self.instance:
            total_qty = self.instance.total_quantity()
            if reserved_qty > total_qty:
                raise serializers.ValidationError({
                    'reserved_quantity': f"Reserved quantity ({reserved_qty}) cannot exceed total stock ({total_qty}). Please add stock inflow first."
                })
        
        return data

class StockRecordSerializer(serializers.ModelSerializer):
    item_name = serializers.CharField(source='item.name', read_only=True)
    material_id = serializers.CharField(source='item.material_id', read_only=True)
    storage_bin_id = serializers.CharField(source='storage_bin.bin_id', read_only=True)
    item = ItemSerializer(read_only=True)

    class Meta:
        model = StockRecord
        fields = ['id', 'item', 'item_name', 'material_id', 'storage_bin', 'storage_bin_id', 'quantity', 'user', 'created_at']
        read_only_fields = ['user', 'item_name', 'material_id', 'storage_bin_id', 'created_at']

class StorageBinSerializer(serializers.ModelSerializer):
    warehouse_name = serializers.CharField(source='warehouse.name', read_only=True)
    warehouse_code = serializers.CharField(source='warehouse.code', read_only=True)
    usage_percentage = serializers.SerializerMethodField()
    created_by = serializers.SerializerMethodField()
    location_display = serializers.SerializerMethodField()
    stock_records = StockRecordSerializer(many=True, read_only=True)

    class Meta:
        model = StorageBin
        fields = [
            'id', 'warehouse', 'warehouse_name', 'warehouse_code', 'bin_id',
            'row', 'rack', 'shelf', 'type', 'capacity', 'current_load',
            'description', 'usage_percentage', 'created_by', 'location_display',
            'created_at', 'updated_at', 'stock_records'
        ]
        read_only_fields = ['user', 'current_load', 'created_at', 'updated_at']

    def get_usage_percentage(self, obj):
        if obj.capacity == 0:
            return 0
        return round((obj.current_load / obj.capacity) * 100, 2)

    def get_created_by(self, obj):
        if obj.user:
            return obj.user.name or obj.user.email
        return '—'

    def get_location_display(self, obj):
        location = f"Row {obj.row}, Rack {obj.rack}"
        if obj.shelf:
            location += f", Shelf {obj.shelf}"
        return location

    def validate(self, data):
        if 'bin_id' in data:
            queryset = StorageBin.objects.filter(bin_id=data['bin_id'])
            if self.instance:
                queryset = queryset.exclude(pk=self.instance.pk)
            if queryset.exists():
                raise serializers.ValidationError({"bin_id": "Bin ID must be unique."})
        
        if 'warehouse' in data and data['warehouse']:
            bin_id = data.get('bin_id')
            if bin_id:
                existing_bin = StorageBin.objects.filter(
                    bin_id=bin_id
                ).exclude(
                    pk=getattr(self.instance, 'pk', None)
                ).first()
                if existing_bin and existing_bin.warehouse and existing_bin.warehouse != data['warehouse']:
                    raise serializers.ValidationError({
                        "warehouse": f"Bin {bin_id} already belongs to warehouse '{existing_bin.warehouse.name}'. Remove it first."
                    })
        
        warehouse = data.get('warehouse', getattr(self.instance, 'warehouse', None))
        row = data.get('row', getattr(self.instance, 'row', None))
        rack = data.get('rack', getattr(self.instance, 'rack', None))
        shelf = data.get('shelf', getattr(self.instance, 'shelf', ''))
        
        if warehouse and row and rack:
            queryset = StorageBin.objects.filter(
                warehouse=warehouse, row=row, rack=rack, shelf=shelf
            )
            if self.instance:
                queryset = queryset.exclude(pk=self.instance.pk)
            if queryset.exists():
                raise serializers.ValidationError({
                    "location": "A bin already exists at this location in the warehouse."
                })
        
        return data



class StockMovementSerializer(serializers.ModelSerializer):
    item_name = serializers.CharField(source='item.name', read_only=True)
    material_id = serializers.CharField(source='item.material_id', read_only=True)
    storage_bin_id = serializers.CharField(source='storage_bin.bin_id', read_only=True)
    batch = serializers.CharField(source='item.batch', read_only=True)
    user_display = serializers.SerializerMethodField()
    warehouse_receipt = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta:
        model = StockMovement
        fields = [
            'id', 'item', 'item_name', 'material_id', 'storage_bin', 'storage_bin_id', 'movement_type',
            'quantity', 'user', 'user_display', 'timestamp', 'notes', 'batch', 'warehouse_receipt'
        ]
        read_only_fields = ['user', 'item_name', 'material_id', 'storage_bin_id', 'timestamp', 'batch', 'user_display', 'warehouse_receipt']

    def get_user_display(self, obj):
        if obj.user:
            if hasattr(obj.user, 'name') and obj.user.name:
                return obj.user.name
            return obj.user.email
        return '—'


class InventoryAlertSerializer(serializers.ModelSerializer):
    item_name = serializers.CharField(source='related_item.name', read_only=True, allow_null=True)
    material_id = serializers.CharField(source='related_item.material_id', read_only=True, allow_null=True)
    bin_id = serializers.CharField(source='related_bin.bin_id', read_only=True, allow_null=True)

    class Meta:
        model = InventoryAlert
        fields = ['id', 'alert_type', 'message', 'related_item', 'item_name', 'material_id', 'related_bin', 'bin_id', 'created_at', 'is_resolved']
        read_only_fields = ['created_at', 'item_name', 'material_id', 'bin_id']

class ExpiryTrackedItemSerializer(serializers.ModelSerializer):
    item_name = serializers.CharField(source='item.name', read_only=True)
    material_id = serializers.CharField(source='item.material_id', read_only=True)

    class Meta:
        model = ExpiryTrackedItem
        fields = ['id', 'item', 'item_name', 'material_id', 'batch', 'quantity', 'expiry_date', 'user', 'created_at']
        read_only_fields = ['user', 'created_at', 'item_name', 'material_id']

class StockInSerializer(serializers.Serializer):
    item_id = serializers.IntegerField()
    storage_bin_id = serializers.IntegerField()
    quantity = serializers.IntegerField(min_value=1)
    notes = serializers.CharField(max_length=255, required=False, allow_blank=True)

    def validate(self, data):
        try:
            item = Item.objects.get(id=data['item_id'])
            storage_bin = StorageBin.objects.get(id=data['storage_bin_id'])
        except Item.DoesNotExist:
            raise serializers.ValidationError("Invalid item_id.")
        except StorageBin.DoesNotExist:
            raise serializers.ValidationError("Invalid storage_bin_id.")

        free_space = storage_bin.capacity - storage_bin.current_load
        if data['quantity'] > free_space:
            InventoryAlert.objects.create(
                user=self.context['request'].user,
                alert_type='CRITICAL',
                message=f"Cannot add {data['quantity']} to bin {storage_bin.bin_id}: insufficient space (available: {free_space}).",
                related_bin=storage_bin,
                related_item=item
            )
            raise serializers.ValidationError(
                f"Insufficient space in bin {storage_bin.bin_id}. Available: {free_space}, requested: {data['quantity']}."
            )

        data['item'] = item
        data['storage_bin'] = storage_bin
        return data

    def save(self):
        with transaction.atomic():
            item = self.validated_data['item']
            storage_bin = self.validated_data['storage_bin']
            quantity = self.validated_data['quantity']
            notes = self.validated_data.get('notes', '')

            stock_record, created = StockRecord.objects.get_or_create(
                item=item,
                storage_bin=storage_bin,
                defaults={'quantity': 0, 'user': self.context['request'].user}
            )
            stock_record.quantity += quantity
            stock_record.save()

            storage_bin.current_load += quantity
            storage_bin.save()

            StockMovement.objects.create(
                user=self.context['request'].user,
                item=item,
                storage_bin=storage_bin,
                movement_type='IN',
                quantity=quantity,
                notes=notes
            )

            logger.info(f"Stock In: {quantity} of {item.name} ({item.material_id}) to {storage_bin.bin_id} by {self.context['request'].user.email}")




class StockOutSerializer(serializers.Serializer):
    item_id = serializers.IntegerField()
    storage_bin_id = serializers.IntegerField()
    quantity = serializers.IntegerField(min_value=1)
    notes = serializers.CharField(max_length=255, required=False, allow_blank=True)
    recipient = serializers.CharField(max_length=255, required=False, allow_blank=True)

    def validate(self, data):
        try:
            item = Item.objects.select_related('user').get(id=data['item_id'])
            storage_bin = StorageBin.objects.select_related('warehouse').get(id=data['storage_bin_id'])
        except Item.DoesNotExist:
            raise serializers.ValidationError("Invalid item_id.")
        except StorageBin.DoesNotExist:
            raise serializers.ValidationError("Invalid storage_bin_id.")

        stock_record = StockRecord.objects.filter(item=item, storage_bin=storage_bin).first()
        if not stock_record or stock_record.quantity < data['quantity']:
            available = stock_record.quantity if stock_record else 0
            InventoryAlert.objects.create(
                user=self.context['request'].user,
                alert_type='CRITICAL',
                message=f"Cannot remove {data['quantity']} of {item.name} ({item.material_id}) from bin {storage_bin.bin_id}: insufficient stock (available: {available}).",
                related_bin=storage_bin,
                related_item=item
            )
            raise serializers.ValidationError(
                f"Insufficient stock in bin {storage_bin.bin_id}. Available: {available}, requested: {data['quantity']}."
            )

        available = item.available_quantity()
        if data['quantity'] > available:
            InventoryAlert.objects.create(
                user=self.context['request'].user,
                alert_type='WARNING',
                message=f"Requested quantity {data['quantity']} exceeds available stock ({available}) for {item.name} ({item.material_id}) due to reservations.",
                related_item=item
            )
            raise serializers.ValidationError(
                f"Requested quantity exceeds available stock ({available}) due to reservations."
            )

        data['item'] = item
        data['storage_bin'] = storage_bin
        data['stock_record'] = stock_record
        return data

    def save(self):
        with transaction.atomic():
            item = self.validated_data['item']
            storage_bin = self.validated_data['storage_bin']
            quantity = self.validated_data['quantity']
            stock_record = self.validated_data['stock_record']
            notes = self.validated_data.get('notes', '')
            recipient = self.validated_data.get('recipient', '')

            # Update stock record
            stock_record.quantity -= quantity
            if stock_record.quantity == 0:
                stock_record.delete()
            else:
                stock_record.save()

            # Update bin's current load
            storage_bin.current_load = max(0, storage_bin.current_load - quantity)

            # Ensure storage_bin has a warehouse
            if not storage_bin.warehouse:
                warehouse, created = Warehouse.objects.get_or_create(
                    user=self.context['request'].user,
                    name="Default Warehouse",
                    code="WH-DEFAULT",
                    defaults={'capacity': 1000}
                )
                storage_bin.warehouse = warehouse
                storage_bin.save()
                logger.info(f"Assigned default warehouse to bin {storage_bin.bin_id}")

            storage_bin.save()

            # Create warehouse receipt first
            if not recipient:
                recipient = notes if notes else (
                    self.context['request'].user.name or
                    self.context['request'].user.email or
                    'Unknown Recipient'
                )
            receipt = WarehouseReceipt.objects.create(
                receipt_number=generate_receipt_number(),
                issued_from_warehouse=storage_bin.warehouse,
                issued_from_bin=storage_bin,
                item=item,
                quantity=quantity,
                recipient=recipient,
                purpose=notes or f"Stock out for {item.name}",
                created_by=self.context['request'].user,
                delivery_to=recipient,
                transfer_order_no=f"TO-{item.id}-{timezone.now().strftime('%Y%m%d%H%M%S')}",  # Temporary unique ID
                plant_site=storage_bin.warehouse.code,
                bin_location=storage_bin.bin_id,
                qty_picked=quantity,
                qty_remaining=item.available_quantity(),
                unloading_point='Default Unloading Point',
                picker=self.context['request'].user.name or self.context['request'].user.email,
                controller='N/A'
            )
            logger.info(
                f"Warehouse Receipt {receipt.receipt_number} created for stock out: "
                f"{quantity} of {item.name} ({item.material_id}) from {storage_bin.bin_id} "
                f"by {self.context['request'].user.email}"
            )

            # Create stock movement with linked receipt
            stock_movement = StockMovement.objects.create(
                user=self.context['request'].user,
                item=item,
                storage_bin=storage_bin,
                movement_type='OUT',
                quantity=quantity,
                notes=notes,
                warehouse_receipt=receipt
            )

            # Update receipt with stock movement
            receipt.stock_movement = stock_movement
            receipt.transfer_order_no = f"TO-{stock_movement.id}"  # Update with final stock movement ID
            receipt.save()

            logger.info(
                f"Stock Out: {quantity} of {item.name} ({item.material_id}) from "
                f"{storage_bin.bin_id} by {self.context['request'].user.email}"
            )
            return stock_movement


class StockOutSerializer(serializers.Serializer):
    item_id = serializers.IntegerField()
    storage_bin_id = serializers.IntegerField()
    quantity = serializers.IntegerField(min_value=1)
    notes = serializers.CharField(max_length=255, required=False, allow_blank=True)
    recipient = serializers.CharField(max_length=255, required=False, allow_blank=True)

    def validate(self, data):
        try:
            item = Item.objects.select_related('user').get(id=data['item_id'])
            storage_bin = StorageBin.objects.select_related('warehouse').get(id=data['storage_bin_id'])
        except Item.DoesNotExist:
            raise serializers.ValidationError("Invalid item_id.")
        except StorageBin.DoesNotExist:
            raise serializers.ValidationError("Invalid storage_bin_id.")

        stock_record = StockRecord.objects.filter(item=item, storage_bin=storage_bin).first()
        if not stock_record or stock_record.quantity < data['quantity']:
            available = stock_record.quantity if stock_record else 0
            InventoryAlert.objects.create(
                user=self.context['request'].user,
                alert_type='CRITICAL',
                message=f"Cannot remove {data['quantity']} of {item.name} ({item.material_id}) from bin {storage_bin.bin_id}: insufficient stock (available: {available}).",
                related_bin=storage_bin,
                related_item=item
            )
            raise serializers.ValidationError(
                f"Insufficient stock in bin {storage_bin.bin_id}. Available: {available}, requested: {data['quantity']}."
            )

        available = item.available_quantity()
        if data['quantity'] > available:
            InventoryAlert.objects.create(
                user=self.context['request'].user,
                alert_type='WARNING',
                message=f"Requested quantity {data['quantity']} exceeds available stock ({available}) for {item.name} ({item.material_id}) due to reservations.",
                related_item=item
            )
            raise serializers.ValidationError(
                f"Requested quantity exceeds available stock ({available}) due to reservations."
            )

        data['item'] = item
        data['storage_bin'] = storage_bin
        data['stock_record'] = stock_record
        return data

    def save(self):
        with transaction.atomic():
            item = self.validated_data['item']
            storage_bin = self.validated_data['storage_bin']
            quantity = self.validated_data['quantity']
            stock_record = self.validated_data['stock_record']
            notes = self.validated_data.get('notes', '')
            recipient = self.validated_data.get('recipient', '')

            # Update stock record
            stock_record.quantity -= quantity
            if stock_record.quantity == 0:
                stock_record.delete()
            else:
                stock_record.save()

            # Update bin's current load
            storage_bin.current_load = max(0, storage_bin.current_load - quantity)

            # Ensure storage_bin has a warehouse
            if not storage_bin.warehouse:
                warehouse, created = Warehouse.objects.get_or_create(
                    user=self.context['request'].user,
                    name="Default Warehouse",
                    code="WH-DEFAULT",
                    defaults={'capacity': 1000}
                )
                storage_bin.warehouse = warehouse
                storage_bin.save()
                logger.info(f"Assigned default warehouse to bin {storage_bin.bin_id}")

            storage_bin.save()

            # Create warehouse receipt first (omit receipt_number, let model generate it)
            if not recipient:
                recipient = notes if notes else (
                    self.context['request'].user.name or
                    self.context['request'].user.email or
                    'Unknown Recipient'
                )
            receipt = WarehouseReceipt.objects.create(
                issued_from_warehouse=storage_bin.warehouse,
                issued_from_bin=storage_bin,
                item=item,
                quantity=quantity,
                recipient=recipient,
                purpose=notes or f"Stock out for {item.name}",
                created_by=self.context['request'].user,
                delivery_to=recipient,
                transfer_order_no=f"TO-{item.id}-{timezone.now().strftime('%Y%m%d%H%M%S')}",  # Temporary unique ID
                plant_site=storage_bin.warehouse.code,
                bin_location=storage_bin.bin_id,
                qty_picked=quantity,
                qty_remaining=item.available_quantity(),
                unloading_point='Default Unloading Point',
                picker=self.context['request'].user.name or self.context['request'].user.email,
                controller='N/A'
            )
            logger.info(
                f"Warehouse Receipt {receipt.receipt_number} created for stock out: "
                f"{quantity} of {item.name} ({item.material_id}) from {storage_bin.bin_id} "
                f"by {self.context['request'].user.email}"
            )

            # Create stock movement with linked receipt
            stock_movement = StockMovement.objects.create(
                user=self.context['request'].user,
                item=item,
                storage_bin=storage_bin,
                movement_type='OUT',
                quantity=quantity,
                notes=notes,
                warehouse_receipt=receipt
            )

            # Update receipt with stock movement
            receipt.stock_movement = stock_movement
            receipt.transfer_order_no = f"TO-{stock_movement.id}"  # Update with final stock movement ID
            receipt.save()

            logger.info(
                f"Stock Out: {quantity} of {item.name} ({item.material_id}) from "
                f"{storage_bin.bin_id} by {self.context['request'].user.email}"
            )
            return stock_movement



class InventoryActivityLogSerializer(serializers.ModelSerializer):
    user_name = serializers.CharField(source='user.name', read_only=True)
    user_email = serializers.CharField(source='user.email', read_only=True)
    
    class Meta:
        model = InventoryActivityLog
        fields = '__all__'
        read_only_fields = ['user', 'timestamp']


class WarehouseReceiptSerializer(serializers.ModelSerializer):
    class Meta:
        model = WarehouseReceipt
        fields = '__all__'
        read_only_fields = ['receipt_number', 'created_at', 'created_by', 'stock_movement']












models.py:


from django.db import models
from django.conf import settings
from django.core.exceptions import ValidationError
import logging
from django.utils import timezone
from django.contrib.auth import get_user_model
from django.db.models import Sum
import random
import uuid

User = get_user_model()
logger = logging.getLogger(__name__)

def generate_material_id():
    # Generate a random 6-digit number (100000 to 999999)
    return str(random.randint(100000, 999999))

class Item(models.Model):
    material_id = models.CharField(max_length=6, unique=True, editable=False, null=True)
    name = models.CharField(max_length=255)
    description = models.CharField(max_length=500, null=True, blank=True)
    part_number = models.CharField(max_length=100, unique=True)
    manufacturer = models.CharField(max_length=255)
    contact = models.CharField(max_length=255)
    batch = models.CharField(max_length=100, blank=True)
    expiry_date = models.DateField(null=True, blank=True)
    min_stock_level = models.PositiveIntegerField(default=0)
    reserved_quantity = models.PositiveIntegerField(default=0)
    custom_fields = models.JSONField(default=dict, blank=True)
    user = models.ForeignKey('accounts.User', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)

    def total_quantity(self):
        if self.pk:  # Only query stock_records if the item has been saved
            return self.stock_records.aggregate(total=Sum('quantity'))['total'] or 0
        return 0

    def available_quantity(self):
        if self.pk:
            return self.total_quantity() - self.reserved_quantity
        return 0

    def clean(self):
        if self.pk and self.reserved_quantity > self.total_quantity():
            raise ValidationError("Reserved quantity cannot exceed total quantity.")

    def save(self, *args, **kwargs):
        if not self.material_id:
            # Keep trying until we get a unique ID (unlikely to collide)
            for _ in range(10):
                candidate = generate_material_id()
                if not Item.objects.filter(material_id=candidate).exists():
                    self.material_id = candidate
                    break
            else:
                raise RuntimeError("Failed to generate a unique Material ID after 10 attempts")
        self.full_clean()  # Run validation before saving
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.name} ({self.material_id})"

    def check_alerts(self):
        """Generate alerts based on item stock levels."""
        total_qty = self.total_quantity()
        available_qty = self.available_quantity()
        
        # Low stock alert
        if total_qty <= self.min_stock_level:
            InventoryAlert.objects.create(
                user=self.user,
                alert_type='WARNING',
                message=f"Item {self.name} ({self.material_id}) is below minimum stock level ({total_qty}/{self.min_stock_level}).",
                related_item=self
            )
            logger.warning(f"Item {self.name} ({self.material_id}) low stock alert triggered.")
        
        # Critical low stock alert (below 10% of min level)
        if total_qty > 0 and total_qty <= (self.min_stock_level * 0.1):
            InventoryAlert.objects.create(
                user=self.user,
                alert_type='CRITICAL',
                message=f"Item {self.name} ({self.material_id}) is critically low ({total_qty}/{self.min_stock_level}).",
                related_item=self
            )
            logger.warning(f"Item {self.name} ({self.material_id}) critical low stock alert triggered.")
        
        # Expiry alert (if item has expiry date)
        if self.expiry_date:
            days_until_expiry = (self.expiry_date - timezone.now().date()).days
            if 0 <= days_until_expiry <= 7:  # Expiring within 7 days
                InventoryAlert.objects.create(
                    user=self.user,
                    alert_type='WARNING',
                    message=f"Item {self.name} ({self.material_id}) expires in {days_until_expiry} days ({self.expiry_date}).",
                    related_item=self
                )
                logger.warning(f"Item {self.name} ({self.material_id}) expiry alert triggered.")
            elif days_until_expiry < 0:  # Already expired
                InventoryAlert.objects.create(
                    user=self.user,
                    alert_type='CRITICAL',
                    message=f"Item {self.name} ({self.material_id}) has expired on {self.expiry_date}.",
                    related_item=self
                )
                logger.warning(f"Item {self.name} ({self.material_id}) expired alert triggered.")

class Warehouse(models.Model):
    name = models.CharField(max_length=255, unique=True)
    code = models.CharField(max_length=50, unique=True)
    description = models.TextField(blank=True)
    address = models.TextField(blank=True)
    city = models.CharField(max_length=100, blank=True)
    state = models.CharField(max_length=100, blank=True)
    country = models.CharField(max_length=100, blank=True, default="Nigeria")
    capacity = models.PositiveIntegerField(help_text="Total capacity in units")
    is_active = models.BooleanField(default=True)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    

    def clean(self):
        if self.capacity <= 0:
            raise ValidationError("Capacity must be a positive number.")
        

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.name} ({self.code})"

    @property
    def total_bins(self):
        return self.bins.count()

    @property
    def used_capacity(self):
        return self.bins.aggregate(total_used=Sum('current_load'))['total_used'] or 0

    @property
    def available_capacity(self):
        return self.capacity - self.used_capacity

    @property
    def usage_percentage(self):
        if self.capacity == 0:
            return 0
        return round((self.used_capacity / self.capacity) * 100, 2)

    def clean(self):
        """Validate that capacity is positive"""
        if self.capacity <= 0:
            raise ValidationError("Capacity must be a positive number.")

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

class StorageBin(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='bins')
    warehouse = models.ForeignKey(Warehouse, on_delete=models.CASCADE, related_name='bins', null=True, blank=True)
    bin_id = models.CharField(max_length=50, unique=True)
    row = models.CharField(max_length=50, db_index=True)
    rack = models.CharField(max_length=50, db_index=True)
    shelf = models.CharField(max_length=50, blank=True)
    type = models.CharField(max_length=100, blank=True)
    capacity = models.PositiveIntegerField()
    current_load = models.PositiveIntegerField(default=0)
    description = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('warehouse', 'row', 'rack', 'shelf')
        indexes = [models.Index(fields=['row', 'rack'])]

    def __str__(self):
        return f"{self.bin_id} ({self.row}-{self.rack})"

    def free_space(self):
        """Calculate available space in the bin."""
        return max(0, self.capacity - self.current_load)

    @property
    def usage_percentage(self):
        if self.capacity == 0:
            return 0
        return round((self.current_load / self.capacity) * 100, 2)

    def clean(self):
        """Validate current_load doesn't exceed capacity."""
        if self.current_load > self.capacity:
            raise ValidationError(f"Current load ({self.current_load}) exceeds capacity ({self.capacity}).")
        if self.capacity < 0:
            raise ValidationError("Capacity cannot be negative.")

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
        self.check_alerts()

    def check_alerts(self):
        """Generate alerts based on bin status."""
        free_space = self.free_space()
        threshold_full = self.capacity * 0.9  # 90% full
        threshold_empty = self.capacity * 0.1  # 10% full

        if self.current_load >= self.capacity:
            InventoryAlert.objects.create(
                user=self.user,
                alert_type='CRITICAL',
                message=f"Bin {self.bin_id} is at full capacity ({self.current_load}/{self.capacity}).",
                related_bin=self
            )
            logger.warning(f"Bin {self.bin_id} full capacity alert triggered.")
        elif self.current_load >= threshold_full:
            InventoryAlert.objects.create(
                user=self.user,
                alert_type='WARNING',
                message=f"Bin {self.bin_id} is nearly full ({self.current_load}/{self.capacity}).",
                related_bin=self
            )
            logger.warning(f"Bin {self.bin_id} nearly full alert triggered.")
        if self.current_load == 0:
            InventoryAlert.objects.create(
                user=self.user,
                alert_type='WARNING',
                message=f"Bin {self.bin_id} is empty.",
                related_bin=self
            )
            logger.warning(f"Bin {self.bin_id} empty alert triggered.")
        elif self.current_load <= threshold_empty:
            InventoryAlert.objects.create(
                user=self.user,
                alert_type='WARNING',
                message=f"Bin {self.bin_id} is nearly empty ({self.current_load}/{self.capacity}).",
                related_bin=self
            )
            logger.warning(f"Bin {self.bin_id} nearly empty alert triggered.")

class StockRecord(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='stock_records')
    item = models.ForeignKey(Item, on_delete=models.CASCADE, related_name='stock_records')
    storage_bin = models.ForeignKey(StorageBin, on_delete=models.CASCADE, related_name='stock_records')
    quantity = models.PositiveIntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ('item', 'storage_bin')

    def __str__(self):
        return f"{self.item.name} ({self.item.material_id}) in {self.storage_bin.bin_id} ({self.quantity})"

    def clean(self):
        """Validate quantity constraints."""
        if self.quantity < 0:
            raise ValidationError("Quantity cannot be negative.")
        if self.storage_bin:
            new_load = self.storage_bin.current_load - (self.quantity or 0) + self.quantity
            if new_load > self.storage_bin.capacity:
                raise ValidationError(
                    f"Adding {self.quantity} to bin {self.storage_bin.bin_id} exceeds capacity "
                    f"({self.storage_bin.current_load}/{self.storage_bin.capacity})."
                )

    def save(self, *args, **kwargs):
        self.full_clean()
        old_quantity = self.quantity if self.pk else 0
        super().save(*args, **kwargs)
        if self.storage_bin:
            self.storage_bin.current_load = self.storage_bin.stock_records.aggregate(
                total=Sum('quantity')
            )['total'] or 0
            self.storage_bin.save()
        self.item.check_alerts()

class StockMovement(models.Model):
    MOVEMENT_TYPES = (
        ('IN', 'Stock In'),
        ('OUT', 'Stock Out'),
    )
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True)
    item = models.ForeignKey(Item, on_delete=models.CASCADE, related_name='movements')
    storage_bin = models.ForeignKey(StorageBin, on_delete=models.CASCADE, related_name='movements')
    movement_type = models.CharField(max_length=50, choices=MOVEMENT_TYPES)
    quantity = models.PositiveIntegerField()
    timestamp = models.DateTimeField(auto_now_add=True)
    notes = models.TextField(blank=True)
    warehouse_receipt = models.ForeignKey(
        'WarehouseReceipt',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='movements'
    )

    def __str__(self):
        return f"{self.movement_type} {self.quantity} of {self.item.name} ({self.item.material_id}) in {self.storage_bin.bin_id}"

    def clean(self):
        if self.quantity <= 0:
            raise ValidationError("Movement quantity must be positive.")

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

class InventoryAlert(models.Model):
    ALERT_TYPES = (
        ('WARNING', 'Warning'),
        ('CRITICAL', 'Critical'),
    )
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='alerts')
    alert_type = models.CharField(max_length=50, choices=ALERT_TYPES)
    message = models.TextField()
    related_item = models.ForeignKey(Item, on_delete=models.CASCADE, null=True, blank=True, related_name='alerts')
    related_bin = models.ForeignKey(StorageBin, on_delete=models.CASCADE, null=True, blank=True, related_name='alerts')
    created_at = models.DateTimeField(auto_now_add=True)
    is_resolved = models.BooleanField(default=False)

    def __str__(self):
        return f"{self.alert_type}: {self.message}"

class ExpiryTrackedItem(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='expiry_items')
    item = models.ForeignKey(Item, on_delete=models.CASCADE, related_name='expiry_records')
    batch = models.CharField(max_length=50)
    quantity = models.PositiveIntegerField()
    expiry_date = models.DateField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.item.name} ({self.item.material_id}) - {self.batch}"

    def clean(self):
        if self.quantity < 0:
            raise ValidationError("Quantity cannot be negative.")

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

class InventoryActivityLog(models.Model):
    ACTION_CHOICES = [
        ('create', 'Create'),
        ('update', 'Update'),
        ('delete', 'Delete'),
        ('stock_in', 'Stock In'),
        ('stock_out', 'Stock Out'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='inventory_activities')
    action = models.CharField(max_length=20, choices=ACTION_CHOICES)
    model_name = models.CharField(max_length=50)
    object_id = models.PositiveIntegerField()
    object_name = models.CharField(max_length=255, blank=True)
    details = models.JSONField(default=dict, blank=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-timestamp']
        verbose_name = 'Inventory Activity Log'
        verbose_name_plural = 'Inventory Activity Logs'
    
    def __str__(self):
        user_name = self.user.name if self.user and self.user.name else (self.user.email if self.user else 'Unknown')
        return f"{user_name} {self.action} {self.model_name} {self.object_name} at {self.timestamp}"




def generate_receipt_number():
    date_str = timezone.now().strftime("%Y%m%d")
    return f"WR-{date_str}-{uuid.uuid4().hex[:6].upper()}"

class WarehouseReceipt(models.Model):
    receipt_number = models.CharField(max_length=50, unique=True)
    issued_from_warehouse = models.ForeignKey(Warehouse, on_delete=models.CASCADE)
    issued_from_bin = models.ForeignKey(StorageBin, on_delete=models.CASCADE)
    item = models.ForeignKey(Item, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField()
    recipient = models.CharField(max_length=255)  # "Delivery To"
    purpose = models.TextField(blank=True)
    created_by = models.ForeignKey('accounts.User', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    stock_movement = models.ForeignKey(StockMovement, on_delete=models.CASCADE, null=True, blank=True)
    old_material_no = models.CharField(max_length=100, null=True, blank=True)

    # Client-specific fields (from your image)
    delivery_to = models.CharField(max_length=255, blank=True)
    transfer_order_no = models.CharField(max_length=100, blank=True)
    plant_site = models.CharField(max_length=100, blank=True)
    bin_location = models.CharField(max_length=100, blank=True)
    qty_picked = models.PositiveIntegerField(default=0)
    qty_remaining = models.PositiveIntegerField(default=0)
    unloading_point = models.CharField(max_length=255, blank=True)
    original_document = models.CharField(max_length=100, blank=True)
    picker = models.CharField(max_length=255, blank=True)
    controller = models.CharField(max_length=255, blank=True)

    def save(self, *args, **kwargs):
        if not self.receipt_number:
            self.receipt_number = f"WR-{timezone.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"
        if self.item:
            self.bin_location = self.issued_from_bin.bin_id
            self.plant_site = self.issued_from_warehouse.code
            self.qty_remaining = self.item.available_quantity()
        super().save(*args, **kwargs)










views.py:
import csv
from django.conf import settings
from rest_framework import viewsets, permissions, status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.decorators import permission_classes
from rest_framework.decorators import api_view  # ← ADD THIS LINE
from rest_framework.decorators import action
from rest_framework.exceptions import PermissionDenied
from django.db.models import Q, Sum, Count
from rest_framework.pagination import PageNumberPagination
from django.utils import timezone
from django.db import transaction
import logging
from .models import Warehouse, StorageBin, Item, StockRecord, StockMovement, InventoryAlert, ExpiryTrackedItem, InventoryActivityLog, WarehouseReceipt
from .serializers import (
    WarehouseSerializer, StorageBinSerializer, ItemSerializer, StockRecordSerializer, 
    StockMovementSerializer, InventoryAlertSerializer, ExpiryTrackedItemSerializer, 
    StockInSerializer, StockOutSerializer, InventoryActivityLogSerializer, WarehouseReceiptSerializer
)

from accounts.permissions import APIKeyPermission
from accounts.models import PagePermission, ActionPermission
from django.http import JsonResponse
from rest_framework.decorators import action
from rest_framework.parsers import MultiPartParser, FormParser
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.decorators import login_required
from io import BytesIO
from django.http import HttpResponse
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch



logger = logging.getLogger(__name__)

ROLE_LEVELS = {
    'staff': 1,
    'finance_manager': 2,
    'operations_manager': 3,
    'md': 4,
    'admin': 99,
}

def get_user_role_level(user):
    return ROLE_LEVELS.get(user.role, 0)

def get_page_required_level(page):
    perm = PagePermission.objects.filter(page_name=page).first()
    return ROLE_LEVELS.get(perm.min_role, 1) if perm else 1

def get_action_required_level(action_name):
    perm = ActionPermission.objects.filter(action_name=action_name).first()
    return ROLE_LEVELS.get(perm.min_role, 1) if perm else 1

def check_permission(user, page=None, action=None):
    user_level = get_user_role_level(user)
    if page:
        required = get_page_required_level(page)
        if user_level < required:
            raise PermissionDenied(f"Access denied: {page} requires role level {required}")
    if action:
        required = get_action_required_level(action)
        if user_level < required:
            raise PermissionDenied(f"Access denied: {action} requires role level {required}")

def log_activity(user, action, model_name, object_id, object_name, details=None):
    try:
        InventoryActivityLog.objects.create(
            user=user,
            action=action,
            model_name=model_name,
            object_id=object_id,
            object_name=object_name,
            details=details or {}
        )
    except Exception as e:
        logger.error(f"Failed to create activity log: {e}")

class StandardResultsSetPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 100

class InventoryMetricsView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        check_permission(request.user, page="inventory_metrics")
        search = request.query_params.get('search', '').strip()
        total_items = Item.objects.filter(Q(name__icontains=search) | Q(part_number__icontains=search)).count() if search else Item.objects.count()
        total_bins = StorageBin.objects.count()
        total_alerts = InventoryAlert.objects.filter(is_resolved=False).count()
        total_movements = StockMovement.objects.count()
        expired_items = Item.objects.filter(expiry_date__lte=timezone.now().date()).count()

        data = [
            {"id": 1, "title": "Total Items", "value": total_items, "change": "+0%", "trend": "neutral"},
            {"id": 2, "title": "Total Bins", "value": total_bins, "change": "+0%", "trend": "neutral"},
            {"id": 3, "title": "Active Alerts", "value": total_alerts, "change": "+0%", "trend": "neutral"},
            {"id": 4, "title": "Total Stock Movements", "value": total_movements, "change": "+0%", "trend": "neutral"},
            {"id": 5, "title": "Expired Items", "value": expired_items, "change": "+0%", "trend": "neutral"},
        ]
        return Response(data)

class ItemViewSet(viewsets.ModelViewSet):
    serializer_class = ItemSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        check_permission(self.request.user, page="items")
        queryset = Item.objects.all().order_by('-id')
        search = self.request.query_params.get('search', '').strip()
        if search:
            queryset = queryset.filter(Q(name__icontains=search) | Q(part_number__icontains=search))
        return queryset

    def perform_create(self, serializer):
        check_permission(self.request.user, action="create_item")
        item = serializer.save(user=self.request.user)
        log_activity(
            user=self.request.user,
            action='create',
            model_name='Item',
            object_id=item.id,
            object_name=item.name,
            details={'part_number': item.part_number, 'manufacturer': item.manufacturer}
        )

    def perform_update(self, serializer):
        check_permission(self.request.user, action="update_item")
        item = serializer.save(user=self.request.user)
        log_activity(
            user=self.request.user,
            action='update',
            model_name='Item',
            object_id=item.id,
            object_name=item.name,
            details={'changes': 'Item updated'}
        )

    def perform_destroy(self, instance):
        check_permission(self.request.user, action="delete_item")
        if instance.stock_records.exists():
            raise PermissionDenied("Cannot delete item with stock records.")
        
        item_name = instance.name
        instance.delete()
        log_activity(
            user=self.request.user,
            action='delete',
            model_name='Item',
            object_id=instance.id,
            object_name=item_name,
            details={'deleted_item': item_name}
        )


    def get_queryset(self):
        check_permission(self.request.user, page="items")
        queryset = Item.objects.all().order_by('-id')
        search = self.request.query_params.get('search', '').strip()
        if search:
            queryset = queryset.filter(
                Q(name__icontains=search) |
                Q(part_number__icontains=search) |
                Q(material_id__icontains=search)  # ← Add this
            )
        return queryset
    





class ImportCSVView(APIView):
    permission_classes = [permissions.IsAuthenticated]
    parser_classes = [MultiPartParser, FormParser]

    def post(self, request):
        """Import items from CSV file"""
        try:
            check_permission(request.user, action="create_item")
            check_permission(request.user, action="import_items_csv")
            
            if 'file' not in request.FILES:
                return Response({'error': 'No file provided'}, status=400)
            
            file = request.FILES['file']
            
            # Validate file type
            if not file.name.endswith('.csv'):
                return Response({'error': 'Only CSV files are allowed'}, status=400)
            
            try:
                # Decode and read CSV
                decoded_file = file.read().decode('utf-8').splitlines()
                csv_reader = csv.DictReader(decoded_file)
                
                created_items = []
                errors = []
                
                # Required fields (adjust based on your Item model)
                required_fields = ['name', 'part_number', 'manufacturer', 'contact', 'material', 'grade']
                
                for row_num, row in enumerate(csv_reader, start=2):  # Start at 2 (header is row 1)
                    try:
                        # Validate required fields
                        missing_fields = [field for field in required_fields if not row.get(field, '').strip()]
                        if missing_fields:
                            errors.append(f"Row {row_num}: Missing required fields: {', '.join(missing_fields)}")
                            continue
                        
                        # Create item
                        item_data = {
                            'name': row['name'].strip(),
                            'description': row.get('description', '').strip(),
                            'part_number': row['part_number'].strip(),
                            'manufacturer': row['manufacturer'].strip(),
                            'contact': row['contact'].strip(),
                            'min_stock_level': int(row.get('min_stock_level', 0)) if row.get('min_stock_level') else 0,
                            'reserved_quantity': int(row.get('reserved_quantity', 0)) if row.get('reserved_quantity') else 0,
                            'custom_fields': {
                                'Material': row.get('material', '').strip(),
                                'Grade': row.get('grade', '').strip()
                            }
                        }
                        
                        # Handle optional fields
                        if row.get('batch'):
                            item_data['batch'] = row['batch'].strip()
                        if row.get('expiry_date'):
                            item_data['expiry_date'] = row['expiry_date'].strip()
                        
                        # Create the item
                        item = Item.objects.create(
                            user=request.user,
                            **item_data
                        )
                        created_items.append(item.name)
                        
                        # Log activity
                        log_activity(
                            user=request.user,
                            action='create',
                            model_name='Item',
                            object_id=item.id,
                            object_name=item.name,
                            details={'source': 'CSV import', 'part_number': item.part_number}
                        )
                        
                    except Exception as e:
                        errors.append(f"Row {row_num}: {str(e)}")
                
                result = {
                    'success': f'Successfully imported {len(created_items)} items',
                    'created_items': created_items,
                    'errors': errors
                }
                
                if errors:
                    return Response(result, status=207)  # Partial success
                return Response(result, status=201)
                
            except UnicodeDecodeError:
                return Response({'error': 'Invalid file encoding. Please use UTF-8 encoded CSV file.'}, status=400)
            except csv.Error as e:
                return Response({'error': f'Invalid CSV format: {str(e)}'}, status=400)
            except Exception as e:
                return Response({'error': f'Unexpected error: {str(e)}'}, status=500)
                
        except PermissionDenied as e:
            return Response({'error': str(e)}, status=403)
        except Exception as e:
            logger.error(f"Import CSV error: {str(e)}")
            return Response({'error': f'Unexpected error: {str(e)}'}, status=500)

            





class StorageBinViewSet(viewsets.ModelViewSet):
    serializer_class = StorageBinSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        check_permission(self.request.user, page="storage_bins")
        queryset = StorageBin.objects.select_related('warehouse').prefetch_related(
            'stock_records__item',  # This ensures item data is loaded efficiently
            'stock_records__storage_bin'
        ).all().order_by('-created_at')
        # Filter by warehouse if provided
        warehouse_id = self.request.query_params.get('warehouse_id')
        if warehouse_id:
            queryset = queryset.filter(warehouse_id=warehouse_id)
            
        search = self.request.query_params.get('search', '').strip()
        if search:
            queryset = queryset.filter(
                Q(bin_id__icontains=search) | 
                Q(description__icontains=search) |
                Q(warehouse__name__icontains=search)
            )
        return queryset

    def perform_create(self, serializer):
        check_permission(self.request.user, action="create_storage_bin")
        
        warehouse = serializer.validated_data.get('warehouse')
        if warehouse:
            if warehouse.bins.count() >= warehouse.capacity:
                raise PermissionDenied(f"Warehouse capacity exceeded. Maximum {warehouse.capacity} bins allowed.")
        
        storage_bin = serializer.save(user=self.request.user)
        log_activity(
            user=self.request.user,
            action='create',
            model_name='StorageBin',
            object_id=storage_bin.id,
            object_name=storage_bin.bin_id,
            details={'warehouse': storage_bin.warehouse.name if storage_bin.warehouse else 'None'}
        )

    def perform_update(self, serializer):
        check_permission(self.request.user, action="update_storage_bin")
        storage_bin = serializer.save()
        log_activity(
            user=self.request.user,
            action='update',
            model_name='StorageBin',
            object_id=storage_bin.id,
            object_name=storage_bin.bin_id,
            details={'changes': 'Storage bin updated'}
        )

    def perform_destroy(self, instance):
        check_permission(self.request.user, action="delete_storage_bin")
        if instance.current_load > 0:
            raise PermissionDenied("Cannot delete bin with stock.")
        
        bin_id = instance.bin_id
        instance.delete()
        log_activity(
            user=self.request.user,
            action='delete',
            model_name='StorageBin',
            object_id=instance.id,
            object_name=bin_id,
            details={'deleted_bin': bin_id}
        )

class StockRecordViewSet(viewsets.ModelViewSet):
    serializer_class = StockRecordSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        check_permission(self.request.user, page="stock_records")
        queryset = StockRecord.objects.select_related('item', 'storage_bin').order_by('-created_at')
        search = self.request.query_params.get('search', '').strip()
        if search:
            queryset = queryset.filter(Q(item__name__icontains=search) | Q(storage_bin__bin_id__icontains=search))
        return queryset

    def perform_create(self, serializer):
        check_permission(self.request.user, action="create_stock_record")
        stock_record = serializer.save(user=self.request.user)
        
        item = stock_record.item
        storage_bin = stock_record.storage_bin
        
        storage_bin.current_load = (storage_bin.current_load or 0) + stock_record.quantity
        storage_bin.save()
        
        log_activity(
            user=self.request.user,
            action='create',
            model_name='StockRecord',
            object_id=stock_record.id,
            object_name=f"{item.name} in {storage_bin.bin_id}",
            details={
                'item_id': item.id,
                'item_name': item.name,
                'storage_bin_id': storage_bin.id,
                'storage_bin_name': storage_bin.bin_id,
                'quantity': stock_record.quantity
            }
        )

    def perform_destroy(self, instance):
        check_permission(self.request.user, action="delete_stock_record")
        
        item = instance.item
        storage_bin = instance.storage_bin
        quantity = instance.quantity
        record_id = instance.id
        item_name = item.name if item else 'Unknown Item'
        bin_id = storage_bin.bin_id if storage_bin else 'Unknown Bin'
        
        if storage_bin:
            storage_bin.current_load = max(0, (storage_bin.current_load or 0) - quantity)
            storage_bin.save()
        
        instance.delete()
        
        log_activity(
            user=self.request.user,
            action='delete',
            model_name='StockRecord',
            object_id=record_id,
            object_name=f"{item_name} in {bin_id}",
            details={
                'item_id': item.id if item else None,
                'item_name': item_name,
                'storage_bin_id': storage_bin.id if storage_bin else None,
                'storage_bin_name': bin_id,
                'quantity': quantity
            }
        )

class StockMovementViewSet(viewsets.ModelViewSet):
    serializer_class = StockMovementSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        check_permission(self.request.user, page="stock_movements")
        queryset = StockMovement.objects.select_related('item', 'storage_bin').order_by('-timestamp')
        search = self.request.query_params.get('search', '').strip()
        if search:
            queryset = queryset.filter(
                Q(item__name__icontains=search) | Q(storage_bin__bin_id__icontains=search)
            )
        return queryset

    def perform_create(self, serializer):
        movement = serializer.save(user=self.request.user)
        log_activity(
            user=self.request.user,
            action=movement.movement_type.lower(),
            model_name='StockMovement',
            object_id=movement.id,
            object_name=f"{movement.item.name} ({movement.movement_type})",
            details={
                'item_id': movement.item.id,
                'item_name': movement.item.name,
                'storage_bin_id': movement.storage_bin.id,
                'storage_bin_name': movement.storage_bin.bin_id,
                'quantity': movement.quantity,
                'movement_type': movement.movement_type
            }
        )

class InventoryAlertViewSet(viewsets.ModelViewSet):
    serializer_class = InventoryAlertSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        check_permission(self.request.user, page="inventory_alerts")
        queryset = InventoryAlert.objects.select_related('related_item', 'related_bin').order_by('-created_at')
        return queryset

    def perform_update(self, serializer):
        check_permission(self.request.user, action="update_inventory_alert")
        alert = serializer.save()
        log_activity(
            user=self.request.user,
            action='update',
            model_name='InventoryAlert',
            object_id=alert.id,
            object_name=f"Alert {alert.alert_type}",
            details={'alert_type': alert.alert_type, 'is_resolved': alert.is_resolved}
        )

    def perform_destroy(self, instance):
        check_permission(self.request.user, action="delete_inventory_alert")
        alert_id = instance.id
        alert_type = instance.alert_type
        instance.delete()
        log_activity(
            user=self.request.user,
            action='delete',
            model_name='InventoryAlert',
            object_id=alert_id,
            object_name=f"Alert {alert_type}",
            details={'deleted_alert': alert_type}
        )

class ExpiryTrackedItemViewSet(viewsets.ModelViewSet):
    serializer_class = ExpiryTrackedItemSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        check_permission(self.request.user, page="expired_items")
        queryset = ExpiryTrackedItem.objects.filter(
            expiry_date__lt=timezone.now().date()
        ).select_related('item', 'user').order_by('-expiry_date')
        
        search = self.request.query_params.get('search', '').strip()
        if search:
            queryset = queryset.filter(
                Q(item__name__icontains=search) | 
                Q(item__part_number__icontains=search) | 
                Q(batch__icontains=search)
            )
        return queryset

    def perform_create(self, serializer):
        check_permission(self.request.user, action="create_expiry_tracked_item")
        expiry_item = serializer.save(user=self.request.user)
        log_activity(
            user=self.request.user,
            action='create',
            model_name='ExpiryTrackedItem',
            object_id=expiry_item.id,
            object_name=f"{expiry_item.item.name} - {expiry_item.batch}",
            details={
                'item_id': expiry_item.item.id,
                'item_name': expiry_item.item.name,
                'batch': expiry_item.batch,
                'expiry_date': expiry_item.expiry_date.isoformat()
            }
        )

    def perform_update(self, serializer):
        check_permission(self.request.user, action="update_expiry_tracked_item")
        expiry_item = serializer.save(user=self.request.user)
        log_activity(
            user=self.request.user,
            action='update',
            model_name='ExpiryTrackedItem',
            object_id=expiry_item.id,
            object_name=f"{expiry_item.item.name} - {expiry_item.batch}",
            details={'changes': 'Expiry tracked item updated'}
        )

    def perform_destroy(self, instance):
        check_permission(self.request.user, action="delete_expiry_tracked_item")
        item_name = instance.item.name if instance.item else 'Unknown Item'
        batch = instance.batch
        instance.delete()
        log_activity(
            user=self.request.user,
            action='delete',
            model_name='ExpiryTrackedItem',
            object_id=instance.id,
            object_name=f"{item_name} - {batch}",
            details={'deleted_item': item_name, 'batch': batch}
        )

class StockInView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        check_permission(request.user, action="stock_in")
        serializer = StockInSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Stock added successfully"}, status=201)
        logger.error(f"Stock In failed: {serializer.errors}")
        return Response(serializer.errors, status=400)

# inventory/views.py
class StockOutView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        check_permission(request.user, action="stock_out")
        check_permission(request.user, action="create_warehouse_receipt")

        serializer = StockOutSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            stock_movement = serializer.save()
            receipt = stock_movement.warehouse_receipt
            if not receipt:
                logger.error(
                    f"No WarehouseReceipt linked to StockMovement {stock_movement.id} "
                    f"by {request.user.email}"
                )
                return Response({
                    "message": "Stock removed successfully, but receipt creation failed",
                    "stock_movement_id": stock_movement.id
                }, status=status.HTTP_201_CREATED)

            return Response({
                "message": "Stock removed successfully",
                "stock_movement_id": stock_movement.id,
                "receipt_id": receipt.id,
                "receipt_number": receipt.receipt_number
            }, status=status.HTTP_201_CREATED)
        
        logger.error(f"Stock Out failed: {serializer.errors}")
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)



class AnalyticsView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        check_permission(request.user, page="inventory_analytics")
        movements = StockMovement.objects.filter(
            timestamp__gte=timezone.now() - timezone.timedelta(days=30)
        ).aggregate(
            total_in=Sum('quantity', filter=Q(movement_type='IN')),
            total_out=Sum('quantity', filter=Q(movement_type='OUT'))
        )
        
        total_stock = StockRecord.objects.aggregate(total=Sum('quantity'))['total'] or 0
        turnover_rate = (movements['total_out'] or 0) / (total_stock or 1)

        bin_usage = StorageBin.objects.annotate(
            movement_count=Count('movements')
        ).order_by('-movement_count')[:5].values('bin_id', 'movement_count')

        alerts_over_time = InventoryAlert.objects.filter(
            created_at__gte=timezone.now() - timezone.timedelta(days=30)
        ).values('alert_type').annotate(count=Count('id'))

        data = {
            "turnover_rate": round(turnover_rate, 2),
            "most_used_bins": list(bin_usage),
            "alerts_over_time": list(alerts_over_time)
        }
        return Response(data)

class WarehouseViewSet(viewsets.ModelViewSet):
    serializer_class = WarehouseSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        check_permission(self.request.user, page="warehouses")
        queryset = Warehouse.objects.all().order_by('-created_at')
        search = self.request.query_params.get('search', '').strip()
        if search:
            queryset = queryset.filter(
                Q(name__icontains=search) | Q(code__icontains=search) | Q(description__icontains=search)
            )
        return queryset

    def perform_create(self, serializer):
        check_permission(self.request.user, action="create_warehouse")
        warehouse = serializer.save(user=self.request.user)
        log_activity(
            user=self.request.user,
            action='create',
            model_name='Warehouse',
            object_id=warehouse.id,
            object_name=warehouse.name,
            details={'code': warehouse.code, 'capacity': warehouse.capacity}
        )

    def perform_update(self, serializer):
        check_permission(self.request.user, action="update_warehouse")
        warehouse = serializer.save()
        log_activity(
            user=self.request.user,
            action='update',
            model_name='Warehouse',
            object_id=warehouse.id,
            object_name=warehouse.name,
            details={'changes': 'Warehouse updated'}
        )

    def perform_destroy(self, instance):
        check_permission(self.request.user, action="delete_warehouse")
        if instance.bins.exists():
            raise PermissionDenied("Cannot delete warehouse with assigned bins.")
        
        warehouse_name = instance.name
        instance.delete()
        log_activity(
            user=self.request.user,
            action='delete',
            model_name='Warehouse',
            object_id=instance.id,
            object_name=warehouse_name,
            details={'deleted_warehouse': warehouse_name}
        )

    @action(detail=True, methods=['get'])
    def bins(self, request, pk=None):
        warehouse = self.get_object()
        bins = StorageBin.objects.filter(warehouse=warehouse).order_by('row', 'rack', 'shelf')
        serializer = StorageBinSerializer(bins, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['post'])
    def add_bin(self, request, pk=None):
        warehouse = self.get_object()
        check_permission(request.user, action="create_storage_bin")
        
        if warehouse.bins.count() >= warehouse.capacity:
            return Response(
                {"error": f"Warehouse capacity exceeded. Maximum {warehouse.capacity} bins allowed."},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = StorageBinSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            storage_bin = serializer.save(warehouse=warehouse, user=request.user)
            log_activity(
                user=request.user,
                action='create',
                model_name='StorageBin',
                object_id=storage_bin.id,
                object_name=storage_bin.bin_id,
                details={
                    'warehouse_id': warehouse.id,
                    'warehouse_name': warehouse.name,
                    'bin_id': storage_bin.bin_id
                }
            )
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class WarehouseAnalyticsView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, warehouse_id=None):
        try:
            check_permission(request.user, page="aisle_rack_dashboard")
            
            bins = StorageBin.objects.select_related('warehouse')
            if warehouse_id:
                bins = bins.filter(warehouse_id=warehouse_id)
                warehouse = Warehouse.objects.get(id=warehouse_id)
            else:
                warehouse = None
            
            total_bins = bins.count()
            
            if total_bins == 0:
                return Response({
                    'total_bins': 0,
                    'total_capacity': 0,
                    'total_used': 0,
                    'empty_bins': 0,
                    'loaded_bins': 0,
                    'utilization_percentage': 0,
                    'warehouse_info': {
                        'name': warehouse.name if warehouse else 'All Warehouses',
                        'capacity': warehouse.capacity if warehouse else Warehouse.objects.aggregate(Sum('capacity'))['capacity__sum'] or 0,
                        'used_capacity': warehouse.used_capacity if warehouse else 0,
                        'available_capacity': warehouse.available_capacity if warehouse else Warehouse.objects.aggregate(Sum('capacity'))['capacity__sum'] or 0,
                        'usage_percentage': warehouse.usage_percentage if warehouse else 0,
                    },
                    'usage_distribution': {
                        'empty': 0,
                        'low_usage': 0,
                        'medium_usage': 0,
                        'high_usage': 0
                    },
                    'message': 'No storage bins found'
                })
            
            from django.db.models import Case, When, FloatField, F, Q
            bins = bins.annotate(
                usage_pct=Case(
                    When(capacity=0, then=0),
                    default=(F('current_load') * 100.0 / F('capacity')),
                    output_field=FloatField()
                )
            )

            aggregation = bins.aggregate(
                total_capacity=Sum('capacity'),
                total_used=Sum('current_load'),
                empty=Count('id', filter=Q(current_load=0)),
                low_usage=Count('id', filter=Q(usage_pct__gt=0, usage_pct__lt=20)),
                medium_usage=Count('id', filter=Q(usage_pct__gte=20, usage_pct__lt=80)),
                high_usage=Count('id', filter=Q(usage_pct__gte=80))
            )
            
            total_capacity = aggregation['total_capacity'] or 0
            total_used = aggregation['total_used'] or 0
            empty_bins = aggregation['empty']
            loaded_bins = total_bins - empty_bins
            
            usage_distribution = {
                'empty': empty_bins,
                'low_usage': aggregation['low_usage'],
                'medium_usage': aggregation['medium_usage'],
                'high_usage': aggregation['high_usage']
            }
            
            utilization_percentage = 0
            if total_capacity > 0:
                utilization_percentage = round((total_used / total_capacity) * 100, 2)
            
            if warehouse:
                warehouse_info = {
                    'name': warehouse.name,
                    'capacity': warehouse.capacity,
                    'used_capacity': warehouse.used_capacity,
                    'available_capacity': warehouse.available_capacity,
                    'usage_percentage': warehouse.usage_percentage
                }
            else:
                total_warehouse_used = Warehouse.objects.aggregate(
                    total_used=Sum('bins__current_load')
                )['total_used'] or 0
                total_warehouse_capacity = Warehouse.objects.aggregate(
                    total_capacity=Sum('capacity')
                )['total_capacity'] or 0
                
                warehouse_info = {
                    'name': 'All Warehouses',
                    'capacity': total_warehouse_capacity,
                    'used_capacity': total_warehouse_used,
                    'available_capacity': total_warehouse_capacity - total_warehouse_used,
                    'usage_percentage': round((total_warehouse_used / total_warehouse_capacity * 100), 2) if total_warehouse_capacity > 0 else 0
                }
            
            analytics_data = {
                'total_bins': total_bins,
                'total_capacity': total_capacity,
                'total_used': total_used,
                'empty_bins': empty_bins,
                'loaded_bins': loaded_bins,
                'utilization_percentage': utilization_percentage,
                'warehouse_info': warehouse_info,
                'usage_distribution': usage_distribution,
                'warehouse_id': warehouse_id
            }
            
            return Response(analytics_data)
            
        except Exception as e:
            logger.error(f"Error in WarehouseAnalyticsView: {str(e)}")
            return Response({
                'error': 'Failed to fetch warehouse analytics',
                'details': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class InventoryActivityLogViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = InventoryActivityLogSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        check_permission(self.request.user, page="inventory_activity_logs")
        queryset = InventoryActivityLog.objects.select_related('user').order_by('-timestamp')
        return queryset




@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def get_unique_states(request):
    states = Warehouse.objects.exclude(state='').values_list('state', flat=True).distinct().order_by('state')
    return Response(list(states))

@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def get_unique_countries(request):
    """Return list of unique non-empty countries from warehouses."""
    countries = Warehouse.objects.exclude(country='').values_list('country', flat=True).distinct().order_by('country')
    return Response(list(countries))



@login_required
def warehouse_receipt_print(request, receipt_id):
    receipt = get_object_or_404(WarehouseReceipt, id=receipt_id)
    return render(request, 'inventory/receipt_print.html', {'receipt': receipt})



class WarehouseReceiptPDFView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, receipt_id):
        try:
            receipt = WarehouseReceipt.objects.select_related(
                'issued_from_warehouse',
                'issued_from_bin',
                'item',
                'created_by'
            ).get(id=receipt_id, created_by=request.user)

            buffer = BytesIO()
            doc = SimpleDocTemplate(
                buffer,
                pagesize=letter,
                topMargin=0.75 * inch,
                bottomMargin=0.75 * inch,
                leftMargin=0.75 * inch,
                rightMargin=0.75 * inch
            )
            elements = []
            styles = getSampleStyleSheet()

            # --- Custom paragraph styles (keeps using ParagraphStyle available in your snippet) ---
            title_style = ParagraphStyle(
                'ReceiptTitle', parent=styles['Heading1'],
                fontSize=16, alignment=1, spaceAfter=8, leading=20,
                textColor=colors.HexColor("#333333")
            )
            section_heading = ParagraphStyle(
                'SectionHeading', parent=styles['Heading3'],
                fontSize=10.5, spaceBefore=6, spaceAfter=6,
                textColor=colors.HexColor("#2b2b2b"), leading=13
            )
            small_info = ParagraphStyle(
                'SmallInfo', parent=styles['Normal'],
                fontSize=9, leading=12, textColor=colors.black
            )

            # === Header Section ===
            # Company Logo (if exists)
            if hasattr(settings, 'COMPANY_LOGO_PATH'):
                try:
                    from reportlab.platypus import Image
                    logo_img = Image(settings.COMPANY_LOGO_PATH, width=1.5*inch, height=0.8*inch)

                    # header with ash-gray left block, large middle title area, right metadata
                    header_table = Table([[
                        logo_img,
                        Paragraph(f"<b>{getattr(settings, 'COMPANY_NAME', '')}</b><br/><span>{getattr(settings, 'COMPANY_TAGLINE', '')}</span>", styles['Title']),
                        Paragraph(
                            f"<b>Receipt No.</b><br/>{receipt.receipt_number}<br/><br/>"
                            f"<b>Date</b><br/>{receipt.created_at.strftime('%d/%m/%Y %H:%M')}",
                            small_info
                        )
                    ]], colWidths=[1.5*inch, 3.8*inch, 2.2*inch])

                    header_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (0, 0), colors.HexColor("#B2B2B2")),  # ash block behind logo
                        ('BACKGROUND', (1, 0), (1, 0), colors.white),               # white center
                        ('BACKGROUND', (2, 0), (2, 0), colors.HexColor("#F6F6F6")), # light ash metadata bg
                        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                        ('ALIGN', (2, 0), (2, 0), 'RIGHT'),
                        ('LEFTPADDING', (0, 0), (-1, -1), 8),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                        ('TOPPADDING', (0, 0), (-1, -1), 10),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                        ('BOX', (0, 0), (-1, -1), 0.5, colors.HexColor("#D0D0D0")),
                    ]))
                    elements.append(header_table)
                    elements.append(Spacer(1, 12))
                except Exception as e:
                    logger.warning(f"Logo not found or failed to load: {str(e)}")
                    # Fallback to text-only header with ash band
                    header_table = Table([[
                        Paragraph(f"<b>{getattr(settings, 'COMPANY_NAME', '')}</b>", styles['Title']),
                        Paragraph(
                            f"<b>Receipt No.</b><br/>{receipt.receipt_number}<br/><br/>"
                            f"<b>Date</b><br/>{receipt.created_at.strftime('%d/%m/%Y %H:%M')}",
                            small_info
                        )
                    ]], colWidths=[5.0*inch, 2.2*inch])
                    header_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (0, 0), colors.HexColor("#B2B2B2")),
                        ('BACKGROUND', (1, 0), (1, 0), colors.HexColor("#F6F6F6")),
                        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                        ('ALIGN', (1, 0), (1, 0), 'RIGHT'),
                        ('LEFTPADDING', (0, 0), (-1, -1), 8),
                        ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                        ('TOPPADDING', (0, 0), (-1, -1), 10),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                        ('BOX', (0, 0), (-1, -1), 0.5, colors.HexColor("#D0D0D0")),
                    ]))
                    elements.append(header_table)
                    elements.append(Spacer(1, 12))
            else:
                # No logo path - still render styled header
                header_table = Table([[
                    Paragraph(f"<b>{getattr(settings, 'COMPANY_NAME', '')}</b>", styles['Title']),
                    Paragraph(
                        f"<b>Receipt No.</b><br/>{receipt.receipt_number}<br/><br/>"
                        f"<b>Date</b><br/>{receipt.created_at.strftime('%d/%m/%Y %H:%M')}",
                        small_info
                    )
                ]], colWidths=[5.0*inch, 2.2*inch])
                header_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (0, 0), colors.HexColor("#B2B2B2")),
                    ('BACKGROUND', (1, 0), (1, 0), colors.HexColor("#F6F6F6")),
                    ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('ALIGN', (1, 0), (1, 0), 'RIGHT'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 8),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                    ('TOPPADDING', (0, 0), (-1, -1), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                    ('BOX', (0, 0), (-1, -1), 0.5, colors.HexColor("#D0D0D0")),
                ]))
                elements.append(header_table)
                elements.append(Spacer(1, 12))

            # === Receipt Title ===
            elements.append(Paragraph("WAREHOUSE STOCK OUT RECEIPT", title_style))
            elements.append(Spacer(1, 8))

            # === Receipt Number & Date (refined visual grid) ===
            header_data = [
                ["Receipt No.", receipt.receipt_number],
                ["Date", receipt.created_at.strftime('%d/%m/%Y %H:%M')],
            ]
            header_table = Table(header_data, colWidths=[2.0*inch, 4.1*inch])
            header_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('GRID', (0, 0), (-1, -1), 0.4, colors.HexColor("#D7D7D7")),
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor("#F3F3F3")),
                ('BACKGROUND', (1, 0), (1, -1), colors.white),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(header_table)
            elements.append(Spacer(1, 12))

            # === Item Details Section ===
            elements.append(Paragraph("<b>ITEM DETAILS</b>", section_heading))
            elements.append(Spacer(1, 6))
            item_data = [
                ["Material ID", receipt.item.material_id if receipt.item else "—"],
                ["Description", receipt.item.name if receipt.item else "—"],
                ["Batch", receipt.item.batch if receipt.item else "—"],
                ["Quantity", str(receipt.quantity)],
            ]
            item_table = Table(item_data, colWidths=[2.0*inch, 4.1*inch])
            item_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('GRID', (0, 0), (-1, -1), 0.35, colors.HexColor("#E0E0E0")),
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor("#FAFAFA")),
                ('LEFTPADDING', (0, 0), (-1, -1), 8),
                ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(item_table)
            elements.append(Spacer(1, 12))

            # === Location & Delivery Section ===
            elements.append(Paragraph("<b>LOCATION & DELIVERY</b>", section_heading))
            elements.append(Spacer(1, 6))
            location_data = [
                ["Plant / Site", receipt.plant_site or "—"],
                ["Bin", receipt.bin_location or "—"],
                ["Delivery To", receipt.delivery_to or "—"],
                ["Unloading Point", receipt.unloading_point or "—"],
                ["Recipient", receipt.recipient or "—"],
                ["Purpose", receipt.purpose or "—"],
            ]
            location_table = Table(location_data, colWidths=[2.0*inch, 4.1*inch])
            location_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('GRID', (0, 0), (-1, -1), 0.35, colors.HexColor("#E0E0E0")),
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor("#FAFAFA")),
                ('LEFTPADDING', (0, 0), (-1, -1), 8),
                ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(location_table)
            elements.append(Spacer(1, 12))

            # === Quantities Section ===
            elements.append(Paragraph("<b>QUANTITIES</b>", section_heading))
            elements.append(Spacer(1, 6))
            qty_data = [
                ["Qty Picked", str(receipt.qty_picked)],
                ["Qty Remaining", str(receipt.qty_remaining)],
            ]
            qty_table = Table(qty_data, colWidths=[2.0*inch, 4.1*inch])
            qty_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('GRID', (0, 0), (-1, -1), 0.35, colors.HexColor("#E0E0E0")),
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor("#FAFAFA")),
                ('LEFTPADDING', (0, 0), (-1, -1), 8),
                ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ]))
            elements.append(qty_table)
            elements.append(Spacer(1, 12))

            # === Signatures Section ===
            elements.append(Paragraph("<b>SIGNATURES</b>", section_heading))
            elements.append(Spacer(1, 6))
            signature_data = [
                ["Picker", receipt.picker or "—"],
                ["Controller", receipt.controller or "—"],
            ]
            signature_table = Table(signature_data, colWidths=[2.0*inch, 4.1*inch])
            signature_table.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('GRID', (0, 0), (-1, -1), 0.35, colors.HexColor("#E0E0E0")),
                ('BACKGROUND', (0, 0), (0, -1), colors.HexColor("#FAFAFA")),
                ('LEFTPADDING', (0, 0), (-1, -1), 8),
                ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                ('TOPPADDING', (0, 0), (-1, -1), 14),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 14),
            ]))
            elements.append(signature_table)
            elements.append(Spacer(1, 18))

            # === Footer Note (dark subtle band) ===
            footer_table = Table([[
                Paragraph("<i>This document is auto-generated. Signatures are required for validation.</i>", styles['Italic']),
                Paragraph(f"{getattr(settings, 'COMPANY_NAME', '')}", small_info)
            ]], colWidths=[4.6*inch, 2.0*inch])
            footer_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, -1), colors.HexColor("#333333")),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.whitesmoke),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (1, 0), (1, 0), 'RIGHT'),
                ('LEFTPADDING', (0, 0), (-1, -1), 10),
                ('RIGHTPADDING', (0, 0), (-1, -1), 10),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ]))
            elements.append(footer_table)

            # Build PDF
            doc.build(elements)

            # Set filename based on item name
            item_name_safe = receipt.item.name.replace(' ', '_').replace('/', '-') if receipt.item else "Item"
            filename = f"{item_name_safe}_kenyon_receipt.pdf"

            buffer.seek(0)
            response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
            response['Content-Disposition'] = f'attachment; filename="{filename}"'
            return response

        except WarehouseReceipt.DoesNotExist:
            return Response({'error': 'Receipt not found'}, status=404)
        except Exception as e:
            logger.error(f"PDF generation error: {str(e)}")
            return Response({'error': 'Failed to generate PDF'}, status=500)





class WarehouseReceiptViewSet(viewsets.ModelViewSet):
    serializer_class = WarehouseReceiptSerializer
    permission_classes = [permissions.IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        return WarehouseReceipt.objects.filter(created_by=self.request.user)

    def perform_update(self, serializer):
        check_permission(self.request.user, action="update_warehouse_receipt")
        serializer.save()

    def perform_destroy(self, instance):
        check_permission(self.request.user, action="delete_warehouse_receipt")
        instance.delete()












urls.py:
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    WarehouseViewSet, WarehouseAnalyticsView,
    StorageBinViewSet, ItemViewSet, StockRecordViewSet,
    StockMovementViewSet, InventoryAlertViewSet, ExpiryTrackedItemViewSet,
    StockInView, StockOutView, InventoryMetricsView, AnalyticsView, InventoryActivityLogViewSet, ImportCSVView, get_unique_states,
    get_unique_countries, warehouse_receipt_print, WarehouseReceiptPDFView, WarehouseReceiptViewSet
)

router = DefaultRouter()
router.register('warehouses', WarehouseViewSet, basename='warehouses')
router.register('bins', StorageBinViewSet, basename='bins')
router.register('items', ItemViewSet, basename='items')
router.register('stocks', StockRecordViewSet, basename='stocks')
router.register('movements', StockMovementViewSet, basename='movements')
router.register('alerts', InventoryAlertViewSet, basename='alerts')
router.register('expiry-tracked-items', ExpiryTrackedItemViewSet, basename='expiry-tracked-items')
router.register('activity-logs', InventoryActivityLogViewSet, basename='activity-logs')
router.register('receipts', WarehouseReceiptViewSet, basename='receipts')

urlpatterns = [
    path('items/import-csv/', ImportCSVView.as_view(), name='import-items-csv'),  # ADD THIS LINE
    path('', include(router.urls)),
    path('metrics/', InventoryMetricsView.as_view(), name='inventory-metrics'),
    path('stock-in/', StockInView.as_view(), name='stock-in'),
    path('stock-out/', StockOutView.as_view(), name='stock-out'),
    path('analytics/', AnalyticsView.as_view(), name='inventory-analytics'),
    path('warehouse-analytics/', WarehouseAnalyticsView.as_view(), name='warehouse-analytics'),
    path('warehouse-analytics/<int:warehouse_id>/', WarehouseAnalyticsView.as_view(), name='warehouse-analytics-detail'),
    path('warehouse-states/', get_unique_states, name='warehouse-states'),
    path('warehouse-countries/', get_unique_countries, name='warehouse-countries'),
    path('receipts/<int:receipt_id>/print/', warehouse_receipt_print, name='receipt-print'),
    path('receipts/<int:receipt_id>/pdf/', WarehouseReceiptPDFView.as_view(), name='warehouse-receipt-pdf'),
]