# rentals/models.py

from django.db import models
from django.conf import settings
from django.core.exceptions import ValidationError
from django.utils import timezone
import logging
from decimal import Decimal

logger = logging.getLogger(__name__)

CURRENCY_CHOICES = [
    ('NGN', 'Nigerian Naira'),
    ('USD', 'US Dollar'),
]

NOTIFICATION_TYPES = [
    ('OVERDUE', 'Overdue Rental'),
    ('ALMOST_OVERDUE', 'Almost Overdue Rental'),
]

SEVERITY_LEVELS = [
    ('INFO', 'Info'),
    ('WARNING', 'Warning'),
    ('CRITICAL', 'Critical'),
]

def rental_image_upload_path(instance, filename):
    return f'rentals/equipment_{instance.id}/{filename}'


class Notification(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='notifications')
    type = models.CharField(max_length=50, choices=NOTIFICATION_TYPES)
    severity = models.CharField(max_length=20, choices=SEVERITY_LEVELS, default='INFO')
    title = models.CharField(max_length=255)
    message = models.TextField()
    is_read = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    related_rental = models.ForeignKey('Rental', on_delete=models.CASCADE, null=True, blank=True)
    related_equipment = models.ForeignKey('Equipment', on_delete=models.CASCADE, null=True, blank=True)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.user.email} - {self.title}"


class Branch(models.Model):
    name = models.CharField(max_length=100, unique=True)
    code = models.CharField(max_length=20, unique=True)
    address = models.TextField()
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name='created_branches'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.name} ({self.code})"

    def delete(self, *args, **kwargs):
        if self.equipment.exists():
            raise ValidationError("Cannot delete branch with assigned equipment.")
        super().delete(*args, **kwargs)

    class Meta:
        ordering = ['name']


class Equipment(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    image = models.ImageField(upload_to=rental_image_upload_path, blank=True, null=True)
    manufacture_date = models.DateField(null=True, blank=True)
    expiry_date = models.DateField(null=True, blank=True)
    category = models.CharField(max_length=100)
    condition = models.CharField(max_length=50)
    location = models.CharField(max_length=100)
    branch = models.ForeignKey(Branch, on_delete=models.PROTECT, related_name='equipment', null=True, blank=True)
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, related_name='equipment')
    created_at = models.DateTimeField(auto_now_add=True)
    total_quantity = models.PositiveIntegerField(default=1)
    available_quantity = models.PositiveIntegerField(default=1)

    def clean(self):
        if self.available_quantity > self.total_quantity:
            raise ValidationError("Available quantity cannot exceed total quantity.")
        if self.available_quantity < 0:
            raise ValidationError("Available quantity cannot be negative.")
        if self.branch is None:
            return
        required_fields = ['name', 'category', 'condition', 'location']
        for field in required_fields:
            if not getattr(self, field):
                raise ValidationError({field: "This field cannot be blank."})

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name


class Reservation(models.Model):
    equipment = models.ForeignKey(Equipment, on_delete=models.CASCADE, related_name='reservations')
    reserved_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='reservations', null=True, blank=True)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)  # null = open-ended
    quantity = models.PositiveIntegerField(default=1)
    created_at = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return f"Reservation for {self.equipment.name} by {self.reserved_by.email}"

    def clean(self):
        if self.end_date and self.start_date > self.end_date:
            raise ValidationError("End date must be after start date.")
        if self.quantity <= 0:
            raise ValidationError("Reservation quantity must be positive.")
        if self.quantity > self.equipment.available_quantity:
            raise ValidationError(f"Only {self.equipment.available_quantity} units available for reservation.")

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)


class Rental(models.Model):
    code = models.CharField(max_length=20, unique=True, editable=False)
    renter = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='rentals')
    equipment = models.ForeignKey(Equipment, on_delete=models.CASCADE, related_name='rentals')
    branch = models.ForeignKey(Branch, on_delete=models.PROTECT, related_name='rentals', null=True, blank=True)
    start_date = models.DateField()
    due_date = models.DateField(null=True, blank=True)  # null = open-ended
    extended_to = models.DateField(null=True, blank=True)  # for extension
    rental_rate = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    currency = models.CharField(max_length=3, choices=CURRENCY_CHOICES, default='NGN')
    quantity = models.PositiveIntegerField(default=1)
    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name='approved_rentals'
    )
    returned = models.BooleanField(default=False)
    returned_at = models.DateTimeField(null=True, blank=True)
    notes = models.TextField(blank=True)
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, related_name='created_rentals')
    created_at = models.DateTimeField(auto_now_add=True)

    @property
    def effective_due_date(self):
        return self.extended_to or self.due_date

    @property
    def is_open_ended(self):
        return self.due_date is None and self.extended_to is None

    @property
    def is_overdue(self):
        if self.returned or self.is_open_ended:
            return False
        due = self.effective_due_date
        return due and due < timezone.now().date()

    @property
    def days_overdue(self):
        if self.is_overdue:
            return (timezone.now().date() - self.effective_due_date).days
        return 0

    @property
    def duration_days(self):
        if not self.start_date:
            return 0
        if self.returned and self.returned_at:
            end = self.returned_at.date()
        elif self.is_open_ended:
            end = timezone.now().date()
        else:
            end = self.effective_due_date or self.start_date
        return max(0, (end - self.start_date).days)

    @property
    def total_rental_cost(self):
        if not self.rental_rate or self.rental_rate <= 0:
            return Decimal('0.00')
        if self.is_open_ended:
            days = self.duration_days
        else:
            if self.effective_due_date:
                days = (self.effective_due_date - self.start_date).days
            else:
                days = 0
        return Decimal(str(self.rental_rate * days * self.quantity)).quantize(Decimal('0.01'))

    @property
    def total_paid(self):
        return self.payments.filter(status='Paid').aggregate(
            total=models.Sum('amount_paid')
        )['total'] or Decimal('0.00')

    @property
    def balance_due(self):
        return max(self.total_rental_cost - self.total_paid, Decimal('0.00'))

    def save(self, *args, **kwargs):
        is_new = not self.pk
        is_return_update = False
        if not is_new:
            old = Rental.objects.get(pk=self.pk)
            is_return_update = (not old.returned) and self.returned

        if is_new:
            super().save(*args, **kwargs)
            self.code = f"RENT-{self.id:06d}"
            self.branch = self.equipment.branch
            super().save(update_fields=['code', 'branch'])

            # Reservation conflict check
            active_res = Reservation.objects.filter(
                equipment=self.equipment,
                is_active=True,
                start_date__lte=self.start_date,
            ).filter(
                models.Q(end_date__isnull=True) | models.Q(end_date__gte=self.start_date)
            ).exists()
            if active_res:
                raise ValidationError("This equipment is currently reserved and cannot be rented.")

            if self.quantity > self.equipment.available_quantity:
                raise ValidationError(f"Only {self.equipment.available_quantity} units available.")

            self.equipment.available_quantity -= self.quantity
            self.equipment.save(update_fields=['available_quantity'])
            self.check_notifications()  # ✅ Generate Notification (NO Alert)

        elif is_return_update:
            self.equipment.available_quantity = min(
                self.equipment.available_quantity + self.quantity,
                self.equipment.total_quantity
            )
            self.equipment.save(update_fields=['available_quantity'])
            if not self.returned_at:
                self.returned_at = timezone.now()
            super().save(*args, **kwargs)

        else:
            super().save(*args, **kwargs)
            self.check_notifications()  # ✅ Also on update (NO Alert)

    def check_notifications(self):
        """Generate Notification records for overdue or almost overdue rentals."""
        if self.returned:
            return

        today = timezone.now().date()
        due = self.effective_due_date

        if not due:
            return  # Open-ended rentals don’t trigger notifications

        days_until_due = (due - today).days

        # Overdue → CRITICAL
        if days_until_due < 0:
            Notification.objects.get_or_create(
                user=self.renter,
                type='OVERDUE',
                defaults={
                    'severity': 'CRITICAL',
                    'title': 'Rental Overdue',
                    'message': f"Rental {self.code} for {self.equipment.name} is overdue by {abs(days_until_due)} days.",
                    'related_rental': self
                }
            )

        # Due in 1–3 days → WARNING
        elif 0 <= days_until_due <= 3:
            Notification.objects.get_or_create(
                user=self.renter,
                type='ALMOST_OVERDUE',
                defaults={
                    'severity': 'WARNING',
                    'title': 'Rental Due Soon',
                    'message': f"Rental {self.code} for {self.equipment.name} is due in {days_until_due} days.",
                    'related_rental': self
                }
            )

    def __str__(self):
        return f"{self.code} - {self.renter.email} - {self.equipment.name} x{self.quantity}"


class RentalPayment(models.Model):
    rental = models.ForeignKey(Rental, on_delete=models.CASCADE, related_name='payments')
    amount_paid = models.DecimalField(max_digits=10, decimal_places=2)
    amount_in_words = models.CharField(max_length=255, blank=True)  # Manual input
    payment_date = models.DateField(auto_now_add=True)
    status = models.CharField(max_length=20, choices=[('Paid', 'Paid'), ('Pending', 'Pending')])
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, related_name='rental_payments')
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.rental.code} - {self.amount_paid} ({self.status})"


class RentalReceipt(models.Model):
    rental = models.OneToOneField(Rental, on_delete=models.CASCADE, related_name='receipt')
    generated_at = models.DateTimeField(auto_now_add=True)
    generated_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True)

    def __str__(self):
        return f"Receipt for {self.rental.code}"



































from rest_framework import serializers
from .models import Equipment, Rental, RentalPayment, Branch, Reservation, Notification
from django.contrib.auth import get_user_model
from decimal import Decimal
import logging
from django.db import models
from django.conf import settings

logger = logging.getLogger(__name__)
User = get_user_model()

class BranchSerializer(serializers.ModelSerializer):
    created_by_name = serializers.SerializerMethodField()

    class Meta:
        model = Branch
        fields = ['id', 'name', 'code', 'address', 'created_by', 'created_by_name', 'created_at']
        read_only_fields = ['created_by', 'created_by_name', 'created_at']

    def get_created_by_name(self, obj):
        user = getattr(obj, 'created_by', None)
        if user:
            return getattr(user, 'full_name', None) or (user.get_full_name() if hasattr(user, 'get_full_name') else None) or user.email
        return "N/A"

class EquipmentSerializer(serializers.ModelSerializer):
    created_by_name = serializers.SerializerMethodField()
    branch_name = serializers.CharField(source='branch.name', read_only=True)
    image = serializers.SerializerMethodField()

    class Meta:
        model = Equipment
        fields = [
            'id', 'name', 'description', 'image', 'manufacture_date', 'expiry_date',
            'category', 'condition', 'location', 'branch', 'branch_name',
            'created_by', 'created_by_name', 'created_at',
            'total_quantity', 'available_quantity'
        ]
        read_only_fields = ['created_by', 'created_by_name', 'created_at']

    def get_image(self, obj):
        if getattr(obj, 'image', None):
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(obj.image.url)
            site = getattr(settings, 'SITE_URL', '')
            return f"{site}{obj.image.url}"
        return None

    def get_created_by_name(self, obj):
        user = getattr(obj, "created_by", None)
        if user:
            return getattr(user, 'full_name', None) or (user.get_full_name() if hasattr(user, 'get_full_name') else None) or user.email
        return ""

    def validate(self, data):
        required = ['name', 'category', 'condition', 'location', 'branch']
        for field in required:
            if not data.get(field):
                raise serializers.ValidationError(f"{field.replace('_', ' ').title()} is required.")
        return data

    def create(self, validated_data):
        validated_data['created_by'] = self.context['request'].user
        return super().create(validated_data)

class ReservationSerializer(serializers.ModelSerializer):
    equipment_name = serializers.CharField(source='equipment.name', read_only=True)
    reserved_for_name = serializers.SerializerMethodField()
    created_by_name = serializers.SerializerMethodField()

    class Meta:
        model = Reservation
        fields = [
            'id', 'equipment', 'equipment_name', 'reserved_for', 'reserved_for_name',
            'start_date', 'end_date', 'quantity', 'is_active', 'created_by', 'created_by_name', 'created_at'
        ]
        read_only_fields = ['created_by', 'created_by_name', 'created_at', 'reserved_for_name', 'equipment_name']

    def get_reserved_for_name(self, obj):
        user = getattr(obj, 'reserved_for', None)
        if user:
            return getattr(user, 'full_name', None) or (user.get_full_name() if hasattr(user, 'get_full_name') else None) or user.email
        return "N/A"

    def get_created_by_name(self, obj):
        user = getattr(obj, 'created_by', None)
        if user:
            return getattr(user, 'full_name', None) or (user.get_full_name() if hasattr(user, 'get_full_name') else None) or user.email
        return "N/A"

    def validate(self, data):
        if data.get('end_date') and data['start_date'] > data['end_date']:
            raise serializers.ValidationError("End date must be after start date.")
        equipment = data.get('equipment', self.instance.equipment if self.instance else None)
        quantity = data.get('quantity', self.instance.quantity if self.instance else 1)
        reserved_sum = equipment.reservations.filter(is_active=True).aggregate(models.Sum('quantity'))['quantity__sum'] or 0 if equipment else 0
        rented_sum = equipment.rentals.filter(returned=False).aggregate(models.Sum('quantity'))['quantity__sum'] or 0 if equipment else 0
        available = (equipment.total_quantity if equipment else 0) - reserved_sum - rented_sum
        if quantity > available:
            raise serializers.ValidationError(f"Only {available} units available for reservation.")
        return data

    def create(self, validated_data):
        validated_data['created_by'] = self.context['request'].user
        return super().create(validated_data)

class RentalPaymentSerializer(serializers.ModelSerializer):
    renter_name = serializers.SerializerMethodField()
    equipment_name = serializers.CharField(source='rental.equipment.name', read_only=True)
    currency = serializers.CharField(source='rental.currency', read_only=True)
    total_rental_cost = serializers.DecimalField(source='rental.total_rental_cost', max_digits=12, decimal_places=2, read_only=True)
    balance_due = serializers.DecimalField(source='rental.balance_due', max_digits=12, decimal_places=2, read_only=True)
    created_by_name = serializers.SerializerMethodField()

    class Meta:
        model = RentalPayment
        fields = [
            'id', 'rental', 'renter_name', 'equipment_name', 'amount_paid', 'amount_in_words',
            'payment_date', 'status', 'created_by', 'created_by_name', 'currency',
            'total_rental_cost', 'balance_due'
        ]
        read_only_fields = ['payment_date', 'created_by', 'created_at', 'created_by_name', 'currency', 'total_rental_cost', 'balance_due']

    def get_renter_name(self, obj):
        rental = getattr(obj, 'rental', None)
        renter = getattr(rental, 'renter', None) if rental else None
        if renter:
            return getattr(renter, 'full_name', None) or (renter.get_full_name() if hasattr(renter, 'get_full_name') else None) or renter.email
        logger.warning(f"Invalid renter for rental payment {obj.id}: {rental.renter if rental else None} (type: {type(rental.renter) if rental else None})")
        return ""

    def get_created_by_name(self, obj):
        user = getattr(obj, 'created_by', None)
        if user:
            return getattr(user, 'full_name', None) or (user.get_full_name() if hasattr(user, 'get_full_name') else None) or user.email
        return ""

    def validate(self, data):
        if data.get('amount_paid', 0) <= 0:
            raise serializers.ValidationError({'amount_paid': 'Amount paid must be positive.'})
        rental = data.get('rental', self.instance.rental if self.instance else None)
        if rental and data.get('amount_paid') > getattr(rental, 'balance_due', 0):
            raise serializers.ValidationError({
                'amount_paid': f"Amount paid ({data['amount_paid']}) exceeds balance due ({rental.balance_due})."
            })
        if not data.get('amount_in_words'):
            raise serializers.ValidationError({'amount_in_words': 'Amount in words is required.'})
        return data

    def create(self, validated_data):
        validated_data['created_by'] = self.context['request'].user
        return super().create(validated_data)

class RentalSerializer(serializers.ModelSerializer):
    renter_name = serializers.SerializerMethodField()
    equipment_name = serializers.CharField(source='equipment.name', read_only=True)
    branch_name = serializers.CharField(source='branch.name', read_only=True)
    created_by_name = serializers.SerializerMethodField()
    total_rental_cost = serializers.DecimalField(max_digits=12, decimal_places=2, read_only=True)
    total_paid = serializers.DecimalField(max_digits=12, decimal_places=2, read_only=True)
    balance_due = serializers.DecimalField(max_digits=12, decimal_places=2, read_only=True)
    is_overdue = serializers.BooleanField(read_only=True)
    days_overdue = serializers.IntegerField(read_only=True)
    duration_days = serializers.IntegerField(read_only=True)
    is_open_ended = serializers.BooleanField(read_only=True)
    payments = RentalPaymentSerializer(many=True, read_only=True)

    class Meta:
        model = Rental
        fields = [
            'id', 'code', 'renter', 'renter_name', 'equipment', 'equipment_name',
            'branch', 'branch_name', 'start_date', 'due_date', 'extended_to',
            'rental_rate', 'currency', 'quantity',
            'returned', 'returned_at', 'notes', 'created_by', 'created_by_name', 'created_at',
            'total_rental_cost', 'total_paid', 'balance_due',
            'is_overdue', 'days_overdue', 'duration_days', 'is_open_ended', 'payments'
        ]
        read_only_fields = [
            'id', 'code', 'branch', 'created_by', 'created_by_name',
            'renter_name', 'equipment_name', 'branch_name',
            'total_rental_cost', 'total_paid', 'balance_due',
            'is_overdue', 'days_overdue', 'duration_days', 'is_open_ended'
        ]

    def get_renter_name(self, obj):
        renter = getattr(obj, "renter", None)
        if renter:
            return getattr(renter, 'full_name', None) or (renter.get_full_name() if hasattr(renter, 'get_full_name') else None) or renter.email
        return ""

    def get_created_by_name(self, obj):
        user = getattr(obj, 'created_by', None)
        if user:
            return getattr(user, 'full_name', None) or (user.get_full_name() if hasattr(user, 'get_full_name') else None) or user.email
        return "N/A"

    def validate(self, data):
        method = self.context['request'].method
        if method == 'POST':
            required = ['equipment', 'renter', 'start_date', 'quantity']
            for field in required:
                if not data.get(field):
                    raise serializers.ValidationError(f"{field.replace('_', ' ').title()} is required.")
            if data['quantity'] <= 0:
                raise serializers.ValidationError("Quantity must be at least 1.")
            if data.get('due_date') and data.get('start_date') and data['start_date'] > data['due_date']:
                raise serializers.ValidationError("Due date must be after start date.")
            
            # Validate equipment availability
            equipment = data['equipment']
            reserved_quantity = equipment.reservations.filter(
                is_active=True,
                start_date__lte=data['start_date'],
                end_date__gte=data['start_date']
            ).aggregate(models.Sum('quantity'))['quantity__sum'] or 0
            rented_quantity = equipment.rentals.filter(returned=False).aggregate(
                models.Sum('quantity'))['quantity__sum'] or 0
            available = equipment.total_quantity - reserved_quantity - rented_quantity
            if data['quantity'] > available:
                raise serializers.ValidationError(f"Only {available} units available for rental.")
        
        elif method == 'PATCH' and 'returned' in data and data['returned']:
            if self.instance and self.instance.returned:
                raise serializers.ValidationError("Rental is already returned.")
        
        return data

    def create(self, validated_data):
        validated_data['created_by'] = self.context['request'].user
        return super().create(validated_data)



        

class NotificationSerializer(serializers.ModelSerializer):
    rental_code = serializers.CharField(source='related_rental.code', read_only=True)
    equipment_name = serializers.CharField(source='related_equipment.name', read_only=True)

    class Meta:
        model = Notification
        fields = ['id', 'type', 'severity', 'title', 'message', 'is_read', 'created_at', 'rental_code', 'equipment_name']








































# rentals/views.py
import logging
from io import BytesIO
from datetime import datetime
from django.http import HttpResponse
from django.utils import timezone
from django.db.models import Q
from django.conf import settings
from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import IsAuthenticated
from rest_framework.pagination import PageNumberPagination
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from decimal import Decimal
from .models import Equipment, Rental, RentalPayment, Branch, Reservation, Notification
from .serializers import (
    EquipmentSerializer, RentalSerializer, RentalPaymentSerializer,
    BranchSerializer, ReservationSerializer, NotificationSerializer
)

logger = logging.getLogger(__name__)

class StandardResultsSetPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 100

class BranchViewSet(ModelViewSet):
    queryset = Branch.objects.all().order_by('name')
    serializer_class = BranchSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

class EquipmentViewSet(ModelViewSet):
    queryset = Equipment.objects.select_related('branch', 'created_by').all().order_by('-created_at')
    serializer_class = EquipmentSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

class RentalViewSet(ModelViewSet):
    queryset = Rental.objects.select_related(
        'renter', 'equipment', 'branch', 'created_by'
    ).prefetch_related('payments').all().order_by('-created_at')
    serializer_class = RentalSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        user = self.request.user
        return self.queryset.filter(
            Q(renter=user) | Q(created_by=user)
        )

    @action(detail=True, methods=['post'])
    def extend_rental(self, request, pk=None):
        rental = self.get_object()
        if rental.is_open_ended:
            return Response({'error': 'Cannot extend open-ended rental.'}, status=400)
        if rental.returned:
            return Response({'error': 'Cannot extend a returned rental.'}, status=400)
        new_due_date_str = request.data.get('new_due_date')
        if not new_due_date_str:
            return Response({'error': 'New due date is required.'}, status=400)
        try:
            new_due_date = datetime.strptime(new_due_date_str, '%Y-%m-%d').date()
        except ValueError:
            return Response({'error': 'Invalid date format. Use YYYY-MM-DD.'}, status=400)
        if new_due_date <= rental.start_date:
            return Response({'error': 'New due date must be after start date.'}, status=400)
        if rental.effective_due_date and new_due_date <= rental.effective_due_date:
            return Response({'error': 'New due date must be after current due date.'}, status=400)
        rental.extended_to = new_due_date
        rental.save(update_fields=['extended_to'])
        return Response({
            'message': 'Rental extended successfully.',
            'extended_to': new_due_date.isoformat()
        })

    @action(detail=True, methods=['post'])
    def mark_returned(self, request, pk=None):
        rental = self.get_object()
        if rental.returned:
            return Response({'error': 'Rental is already returned.'}, status=400)
        rental.returned = True
        rental.returned_at = timezone.now()
        rental.save()
        return Response({'message': 'Rental marked as returned.'})

    @action(detail=False, methods=['post'])
    def bulk_return(self, request):
        rental_ids = request.data.get('ids', [])
        if not isinstance(rental_ids, list):
            return Response({'error': 'Invalid ids payload. Must be a list of ids.'}, status=400)
        updated = 0
        for rental_id in rental_ids:
            try:
                rental = Rental.objects.get(id=rental_id, returned=False)
                rental.returned = True
                rental.returned_at = timezone.now()
                rental.save()
                updated += 1
            except Rental.DoesNotExist:
                continue
        return Response({'message': f'{updated} rentals marked as returned.'})

    @action(detail=False, methods=['post'])
    def bulk_delete(self, request):
        rental_ids = request.data.get('ids', [])
        if not isinstance(rental_ids, list):
            return Response({'error': 'Invalid ids payload. Must be a list of ids.'}, status=400)
        deleted = 0
        for rental_id in rental_ids:
            try:
                rental = Rental.objects.get(id=rental_id)
                if not rental.returned:
                    continue
                rental.delete()
                deleted += 1
            except Rental.DoesNotExist:
                continue
        return Response({'message': f'{deleted} rentals deleted.'})

    @action(detail=True, methods=['get'])
    def receipt_pdf(self, request, pk=None):
        rental = self.get_object()
        buffer = BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=letter,
            topMargin=0.75 * inch,
            bottomMargin=0.75 * inch,
            leftMargin=0.75 * inch,
            rightMargin=0.75 * inch
        )
        elements = []
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'ReceiptTitle', parent=styles['Heading1'],
            fontSize=16, alignment=1, spaceAfter=8, leading=20,
            textColor=colors.HexColor("#333333")
        )
        section_heading = ParagraphStyle(
            'SectionHeading', parent=styles['Heading3'],
            fontSize=10.5, spaceBefore=6, spaceAfter=6,
            textColor=colors.HexColor("#2b2b2b"), leading=13
        )
        small_info = ParagraphStyle(
            'SmallInfo', parent=styles['Normal'],
            fontSize=9, leading=12, textColor=colors.black
        )

        # Header
        try:
            if getattr(settings, 'COMPANY_LOGO_PATH', None):
                logo_img = Image(settings.COMPANY_LOGO_PATH, width=1.0 * inch, height=0.6 * inch)
                header_table = Table([[  
                    logo_img,
                    Paragraph(f"<b>{getattr(settings, 'COMPANY_NAME', '')}</b><br/><span>{getattr(settings, 'COMPANY_TAGLINE', '')}</span>", styles['Title']),
                    Paragraph(
                        f"<b>Receipt No.</b><br/>{rental.code}<br/><br/>"
                        f"<b>Date</b><br/>{rental.created_at.strftime('%d/%m/%Y %H:%M')}",
                        small_info
                    )
                ]], colWidths=[1.0 * inch, 4.3 * inch, 2.2 * inch])
                header_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (0, 0), colors.HexColor("#B2B2B2")),
                    ('BACKGROUND', (1, 0), (1, 0), colors.white),
                    ('BACKGROUND', (2, 0), (2, 0), colors.HexColor("#F6F6F6")),
                    ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('ALIGN', (2, 0), (2, 0), 'RIGHT'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 8),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 8),
                    ('TOPPADDING', (0, 0), (-1, -1), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 10),
                    ('BOX', (0, 0), (-1, -1), 0.5, colors.HexColor("#D0D0D0")),
                ]))
                elements.append(header_table)
                elements.append(Spacer(1, 12))
            else:
                raise Exception("No company logo configured")
        except Exception as e:
            logger.warning(f"Logo load failed or no logo configured: {e}")
            header_table = Table([[  
                Paragraph(f"<b>{getattr(settings, 'COMPANY_NAME', '')}</b>", styles['Title']),
                Paragraph(
                    f"<b>Receipt No.</b><br/>{rental.code}<br/><br/>"
                    f"<b>Date</b><br/>{rental.created_at.strftime('%d/%m/%Y %H:%M')}",
                    small_info
                )
            ]], colWidths=[5.3 * inch, 2.2 * inch])
            header_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, 0), colors.HexColor("#B2B2B2")),
                ('BACKGROUND', (1, 0), (1, 0), colors.HexColor("#F6F6F6")),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (1, 0), (1, 0), 'RIGHT'),
                ('BOX', (0, 0), (-1, -1), 0.5, colors.HexColor("#D0D0D0")),
            ]))
            elements.append(header_table)
            elements.append(Spacer(1, 12))

        # Title
        elements.append(Paragraph("EQUIPMENT RENTAL RECEIPT", title_style))
        elements.append(Spacer(1, 8))

        # Rental Info
        elements.append(Paragraph("<b>RENTAL DETAILS</b>", section_heading))
        rental_data = [
            ["Rental Code", rental.code],
            ["Renter", rental.renter.email],
            ["Equipment", rental.equipment.name if rental.equipment else "—"],
            ["Quantity", str(rental.quantity)],
            ["Start Date", rental.start_date.strftime('%d/%m/%Y') if rental.start_date else "—"],
            ["Due Date", rental.effective_due_date.strftime('%d/%m/%Y') if rental.effective_due_date else "Open-ended"],
            ["Status", "Returned" if rental.returned else "Active"],
        ]
        rental_table = Table(rental_data, colWidths=[2.0 * inch, 4.1 * inch])
        rental_table.setStyle(TableStyle([
            ('GRID', (0, 0), (-1, -1), 0.35, colors.HexColor("#E0E0E0")),
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor("#FAFAFA")),
            ('LEFTPADDING', (0, 0), (-1, -1), 8),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
        ]))
        elements.append(rental_table)
        elements.append(Spacer(1, 12))

        # Financial Summary
        elements.append(Paragraph("<b>FINANCIAL SUMMARY</b>", section_heading))
        fin_data = [
            ["Rental Rate", f"{rental.rental_rate or 0} {rental.currency}/day"],
            ["Duration (days)", str(rental.duration_days)],
            ["Total Incurred", f"{rental.total_rental_cost} {rental.currency}"],
            ["Total Paid", f"{rental.total_paid} {rental.currency}"],
            ["Balance Due", f"{rental.balance_due} {rental.currency}"],
        ]
        fin_table = Table(fin_data, colWidths=[2.0 * inch, 4.1 * inch])
        fin_table.setStyle(TableStyle([
            ('GRID', (0, 0), (-1, -1), 0.35, colors.HexColor("#E0E0E0")),
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor("#FAFAFA")),
            ('LEFTPADDING', (0, 0), (-1, -1), 8),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
        ]))
        elements.append(fin_table)
        elements.append(Spacer(1, 12))

        # Payments
        elements.append(Paragraph("<b>PAYMENTS</b>", section_heading))
        payment_rows = [["Date", "Amount", "In Words", "Status"]]
        for p in rental.payments.all():
            payment_rows.append([
                p.payment_date.strftime('%d/%m/%Y'),
                f"{p.amount_paid} {rental.currency}",
                p.amount_in_words or "—",
                p.status
            ])
        if len(payment_rows) == 1:
            payment_rows.append(["—", "—", "—", "No payments"])
        pay_table = Table(payment_rows, colWidths=[1.2 * inch, 1.5 * inch, 2.4 * inch, 1.0 * inch])
        pay_table.setStyle(TableStyle([
            ('GRID', (0, 0), (-1, -1), 0.35, colors.HexColor("#E0E0E0")),
            ('BACKGROUND', (0, 0), (0, 0), colors.HexColor("#E0E0E0")),
            ('LEFTPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
        ]))
        elements.append(pay_table)
        elements.append(Spacer(1, 18))

        # Footer
        footer_table = Table([[  
            Paragraph("<i>This rental receipt is auto-generated.</i>", styles['Italic']),
            Paragraph(f"{getattr(settings, 'COMPANY_NAME', '')}", small_info)
        ]], colWidths=[4.6 * inch, 2.0 * inch])
        footer_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, -1), colors.HexColor("#333333")),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.whitesmoke),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (1, 0), (1, 0), 'RIGHT'),
        ]))
        elements.append(footer_table)

        doc.build(elements)
        buffer.seek(0)
        filename = f"Rental_{rental.code}_receipt.pdf"
        response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        return response

class ReservationViewSet(ModelViewSet):
    queryset = Reservation.objects.select_related('equipment', 'reserved_by').all().order_by('-created_at')
    serializer_class = ReservationSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        user = self.request.user
        return self.queryset.filter(reserved_by=user)

    def perform_create(self, serializer):
        serializer.save(reserved_by=self.request.user)

class RentalPaymentViewSet(ModelViewSet):
    queryset = RentalPayment.objects.select_related('rental__renter', 'rental__equipment').all().order_by('-created_at')
    serializer_class = RentalPaymentSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        user = self.request.user
        return self.queryset.filter(
            Q(rental__renter=user) | Q(rental__created_by=user) | Q(created_by=user)
        )

    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)

class EquipmentReportPDFView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        equipment_list = Equipment.objects.select_related('branch').all().order_by('name')
        buffer = BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=letter,
            topMargin=0.75 * inch,
            bottomMargin=0.75 * inch,
            leftMargin=0.75 * inch,
            rightMargin=0.75 * inch
        )
        elements = []
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'ReportTitle', parent=styles['Heading1'],
            fontSize=16, alignment=1, spaceAfter=12, leading=20,
            textColor=colors.HexColor("#333333")
        )
        section_heading = ParagraphStyle(
            'SectionHeading', parent=styles['Heading3'],
            fontSize=11, spaceBefore=8, spaceAfter=6,
            textColor=colors.HexColor("#2b2b2b")
        )
        normal = styles['Normal']
        elements.append(Paragraph("EQUIPMENT INVENTORY REPORT", title_style))
        elements.append(Paragraph(f"Generated on: {timezone.now().strftime('%d/%m/%Y %H:%M')}", normal))
        elements.append(Spacer(1, 12))
        table_data = [
            ["#", "Name", "Category", "Branch", "Total Qty", "Available Qty", "Status", "Expiry"]
        ]
        for idx, eq in enumerate(equipment_list, 1):
            status = "Available" if eq.available_quantity == eq.total_quantity else "Partially Available" if eq.available_quantity > 0 else "Unavailable"
            expiry = eq.expiry_date.strftime('%d/%m/%Y') if eq.expiry_date else "—"
            if eq.expiry_date and eq.expiry_date < timezone.now().date():
                expiry = f"EXPIRED ({expiry})"
            table_data.append([
                str(idx),
                eq.name,
                eq.category,
                eq.branch.name if eq.branch else "—",
                str(eq.total_quantity),
                str(eq.available_quantity),
                status,
                expiry
            ])
        col_widths = [0.4 * inch, 1.5 * inch, 1.0 * inch, 1.2 * inch, 0.8 * inch, 0.9 * inch, 1.0 * inch, 1.2 * inch]
        table = Table(table_data, colWidths=col_widths)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor("#4CAF50")),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor("#CCCCCC")),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ]))
        elements.append(table)
        doc.build(elements)
        buffer.seek(0)
        response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
        response['Content-Disposition'] = 'attachment; filename="equipment_inventory_report.pdf"'
        return response

class NotificationViewSet(ModelViewSet):
    serializer_class = NotificationSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardResultsSetPagination
    queryset = Notification.objects.all()

    def get_queryset(self):
        return self.queryset.filter(user=self.request.user)

    @action(detail=False, methods=['post'])
    def mark_all_as_read(self, request):
        self.get_queryset().update(is_read=True)
        return Response({'status': 'success'})

    @action(detail=True, methods=['post'])
    def mark_as_read(self, request, pk=None):
        notification = self.get_object()
        notification.is_read = True
        notification.save()
        return Response({'status': 'success'})


































# rentals/urls.py

from rest_framework.routers import DefaultRouter
from django.urls import path, include
from .views import BranchViewSet, EquipmentViewSet, RentalViewSet, RentalPaymentViewSet, ReservationViewSet, EquipmentReportPDFView, NotificationViewSet

router = DefaultRouter()
router.register(r'branches', BranchViewSet)
router.register(r'equipment', EquipmentViewSet)
router.register(r'rentals', RentalViewSet)
router.register(r'payments', RentalPaymentViewSet)
router.register(r'reservations', ReservationViewSet)
router.register(r'notifications', NotificationViewSet)

urlpatterns = [
    path('', include(router.urls)),
    path('reports/equipment-pdf/', EquipmentReportPDFView.as_view(), name='equipment-report-pdf'),
]